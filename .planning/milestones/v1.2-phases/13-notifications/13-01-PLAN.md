---
phase: 13-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/pipeline/pipeline/notifier.py
  - apps/pipeline/tests/pipeline/test_notifier.py
  - apps/pipeline/pipeline/orchestrator.py
  - apps/pipeline/pipeline/config.py
  - apps/pipeline/main.py
autonomous: true
requirements: [NOTIF-01, NOTIF-02]

must_haves:
  truths:
    - "When update-mode detects and processes new content, a Moshi push notification is sent to the operator's phone"
    - "The notification message includes meeting names and content types (e.g., 'Jan 15 Council (minutes), Feb 3 Council (video)')"
    - "When no new content is found, no notification is sent"
    - "If MOSHI_TOKEN is not set, notification is silently skipped (no crash)"
  artifacts:
    - path: "apps/pipeline/pipeline/notifier.py"
      provides: "Moshi push notification module"
      exports: ["send_update_notification"]
    - path: "apps/pipeline/tests/pipeline/test_notifier.py"
      provides: "Tests for notifier module"
      min_lines: 40
  key_links:
    - from: "apps/pipeline/pipeline/orchestrator.py"
      to: "apps/pipeline/pipeline/notifier.py"
      via: "import and call send_update_notification(report) at end of run_update_mode()"
      pattern: "send_update_notification"
    - from: "apps/pipeline/pipeline/notifier.py"
      to: "https://api.getmoshi.app/api/webhook"
      via: "HTTP POST with MOSHI_TOKEN"
      pattern: "api.getmoshi.app"
    - from: "apps/pipeline/pipeline/notifier.py"
      to: "apps/pipeline/pipeline/update_detector.py"
      via: "accepts ChangeReport dataclass"
      pattern: "ChangeReport"
---

<objective>
Add Moshi push notification support to the pipeline so the operator receives a phone notification when update-mode finds and processes new content.

Purpose: When the pipeline runs daily (Phase 14), the operator needs to know whether new content was found without checking logs. A push notification on their phone with a concise summary closes this feedback loop.

Output: `notifier.py` module with `send_update_notification()`, wired into the orchestrator's `run_update_mode()` method, with tests.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-update-detection/12-02-SUMMARY.md
@apps/pipeline/pipeline/update_detector.py
@apps/pipeline/pipeline/orchestrator.py
@apps/pipeline/pipeline/config.py
@apps/pipeline/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notifier module with Moshi push notification and tests</name>
  <files>
    apps/pipeline/pipeline/notifier.py
    apps/pipeline/pipeline/config.py
    apps/pipeline/tests/pipeline/test_notifier.py
  </files>
  <action>
Create `apps/pipeline/pipeline/notifier.py` with a `send_update_notification(report: ChangeReport, processed_count: int = 0)` function:

1. Read `MOSHI_TOKEN` from `pipeline.config` (add `MOSHI_TOKEN = os.environ.get("MOSHI_TOKEN")` to config.py).

2. If `MOSHI_TOKEN` is not set or `report.total_changes == 0`, return early silently. Do NOT send a notification when nothing changed.

3. Build a human-readable summary message from the ChangeReport. Format:
   - Title: "Pipeline Update" (or "Pipeline: {N} meetings updated" if processed_count > 0)
   - Message body: one line per meeting change, format "{date} {type} ({content_type})" where content_type is "minutes", "agenda", "video", etc. derived from `change.details`.
   - Example message: "Jan 15 Council (minutes), Feb 3 Council (video)"
   - Keep message concise -- Moshi notifications have limited display space. If more than 5 meetings, show first 5 and append "+N more".

4. Send HTTP POST to `https://api.getmoshi.app/api/webhook` with JSON body:
   ```json
   {
     "token": "<MOSHI_TOKEN>",
     "title": "Pipeline: 3 meetings updated",
     "message": "Jan 15 Council (minutes)\nFeb 3 Council (video)\nMar 1 Special (agenda)"
   }
   ```
   Use `requests.post()` with a 10-second timeout. Catch all exceptions and print a warning (never crash the pipeline over a notification failure).

5. Print a log line: `[notify] Push notification sent: {title}` on success, or `[notify] Failed to send notification: {error}` on failure.

6. Add `MOSHI_TOKEN` to `apps/pipeline/pipeline/config.py` alongside the other env vars.

7. Create `apps/pipeline/tests/pipeline/test_notifier.py` with tests using `responses` library (already in dev deps) to mock the HTTP call:
   - `test_sends_notification_on_changes` -- mock POST, verify it was called with correct URL, token, title, and message body
   - `test_skips_when_no_changes` -- report with 0 changes, verify no HTTP call made
   - `test_skips_when_no_token` -- patch MOSHI_TOKEN to None, verify no HTTP call
   - `test_handles_http_error_gracefully` -- mock 500 response, verify no exception raised
   - `test_message_truncation` -- report with 8 meetings, verify message shows first 5 + "+3 more"
   - `test_summary_format` -- verify the meeting summary line format includes date, type, and content type
  </action>
  <verify>
    cd apps/pipeline && uv run pytest tests/pipeline/test_notifier.py -v
    All 6 tests pass.
  </verify>
  <done>
    notifier.py exists with send_update_notification(). MOSHI_TOKEN added to config.py. All 6 tests pass. Function gracefully handles missing token and HTTP errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire notifier into orchestrator run_update_mode</name>
  <files>
    apps/pipeline/pipeline/orchestrator.py
    apps/pipeline/main.py
  </files>
  <action>
1. In `apps/pipeline/pipeline/orchestrator.py`, modify `run_update_mode()`:
   - At the END of the method (after the "Update complete: N meetings re-processed" print), add a lazy import and call:
     ```python
     from pipeline.notifier import send_update_notification
     send_update_notification(report, processed_count=processed)
     ```
   - Use lazy import (inside the method) to match the existing pattern used for UpdateDetector.

2. Do NOT add notification to `run_update_check()` -- that's a dry-run mode and should not notify.

3. In `apps/pipeline/main.py`, add a `--notify` flag (default: True for update-mode). Actually, do NOT add a flag -- notifications should always fire in update-mode when MOSHI_TOKEN is set. The env var itself is the on/off switch. Keep it simple.

4. Verify existing orchestrator tests still pass:
   ```
   cd apps/pipeline && uv run pytest tests/orchestrator/ -v
   ```

5. Verify the full test suite still passes:
   ```
   cd apps/pipeline && uv run pytest -v
   ```
  </action>
  <verify>
    cd apps/pipeline && uv run pytest -v
    All tests pass (existing + new notifier tests). No regressions.
  </verify>
  <done>
    run_update_mode() calls send_update_notification(report, processed) at the end. When MOSHI_TOKEN is set and changes were found+processed, operator gets a push notification. When no token or no changes, nothing happens. Full test suite green.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/pipeline/test_notifier.py -v` -- all notifier tests pass
2. `uv run pytest tests/orchestrator/ -v` -- orchestrator tests still pass (no regression)
3. `uv run pytest -v` -- full pipeline test suite green
4. Grep for `send_update_notification` in orchestrator.py -- present in run_update_mode()
5. Grep for `MOSHI_TOKEN` in config.py -- env var loaded
6. Grep for `api.getmoshi.app` in notifier.py -- correct endpoint
</verification>

<success_criteria>
- notifier.py module exists with send_update_notification() function
- Function formats ChangeReport into concise meeting summary with dates, types, and content types
- Function sends Moshi push notification via HTTP POST when MOSHI_TOKEN is set and changes exist
- Function silently skips when no token, no changes, or HTTP error (never crashes pipeline)
- run_update_mode() calls notifier at the end with the report and processed count
- run_update_check() does NOT call notifier (dry-run only)
- All tests pass including 6+ new notifier tests
</success_criteria>

<output>
After completion, create `.planning/phases/13-notifications/13-01-SUMMARY.md`
</output>
