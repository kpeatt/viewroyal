---
phase: 12-update-detection
plan: 02
type: execute
wave: 2
depends_on:
  - 12-01
files_modified:
  - apps/pipeline/main.py
  - apps/pipeline/pipeline/orchestrator.py
  - apps/pipeline/tests/orchestrator/test_orchestrator.py
autonomous: true
requirements:
  - DETECT-03

must_haves:
  truths:
    - "Running `uv run python main.py --check-updates` prints a report of meetings with new content without processing anything"
    - "Running `uv run python main.py --update-mode` scrapes CivicWeb, detects changes, and only re-processes meetings with new documents or video"
    - "Meetings with no new content are skipped entirely during update-mode ingestion"
    - "After update-mode re-ingestion, new content (documents, video/transcript) is visible in the web app"
  artifacts:
    - path: "apps/pipeline/main.py"
      provides: "--check-updates and --update-mode CLI flags"
      contains: "check_updates|update_mode"
    - path: "apps/pipeline/pipeline/orchestrator.py"
      provides: "run_update_check() and run_update_mode() methods on Archiver"
      contains: "run_update_check|run_update_mode"
    - path: "apps/pipeline/tests/orchestrator/test_orchestrator.py"
      provides: "Tests for update mode integration"
      contains: "test_run_update"
  key_links:
    - from: "apps/pipeline/pipeline/orchestrator.py"
      to: "pipeline.update_detector.UpdateDetector"
      via: "Archiver creates UpdateDetector and calls detect_all_changes()"
      pattern: "UpdateDetector|detect_all_changes"
    - from: "apps/pipeline/pipeline/orchestrator.py"
      to: "pipeline.orchestrator.Archiver._ingest_meetings"
      via: "Passes change report's meeting paths to _ingest_meetings for selective re-ingestion"
      pattern: "_ingest_meetings.*target_folder|updated_paths"
    - from: "apps/pipeline/main.py"
      to: "pipeline.orchestrator.Archiver"
      via: "CLI flags route to new Archiver methods"
      pattern: "args.check_updates|args.update_mode"
---

<objective>
Wire the UpdateDetector into the pipeline's CLI and Archiver, creating two new modes: `--check-updates` (dry-run report only) and `--update-mode` (scrape + detect + selectively re-process only changed meetings). This completes DETECT-03 by ensuring only meetings with detected changes are re-ingested.

Purpose: Without this integration, the detection module from Plan 01 isn't usable. This plan makes it a first-class pipeline mode that operators can run daily.

Output: Two new CLI flags, two new Archiver methods, integration tests.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-update-detection/12-01-SUMMARY.md

@apps/pipeline/main.py
@apps/pipeline/pipeline/orchestrator.py
@apps/pipeline/pipeline/update_detector.py
@apps/pipeline/tests/orchestrator/test_orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add update check and update mode methods to Archiver</name>
  <files>apps/pipeline/pipeline/orchestrator.py</files>
  <action>
Add two new methods to the `Archiver` class in `orchestrator.py`:

1. **`run_update_check(self) -> ChangeReport`**:
   - Import `UpdateDetector` from `pipeline.update_detector` (lazy import inside method to keep module lightweight)
   - Create Supabase client (same pattern as `_ingest_meetings`)
   - First run `self.scraper.scrape_recursive()` to download any new files from CivicWeb (the scraper is idempotent -- skips existing files)
   - Create `UpdateDetector(archive_root=self.archive_root, scraper=self.scraper, vimeo_client=self.vimeo_client)`
   - Call `detector.detect_all_changes(supabase=supabase)` to get the `ChangeReport`
   - Print the report in human-readable format:
     ```
     === Update Check Report ===
     Checked at: 2026-02-19T10:30:00Z

     New Documents (3 meetings):
       2026-01-15 Council: Minutes PDF available
       2026-01-29 Council: Minutes PDF available
       2026-02-05 Committee of the Whole: New agenda items

     New Video (1 meeting):
       2026-02-12 Council: Vimeo video found (no local audio)

     Total: 4 meetings with new content
     ```
   - Return the `ChangeReport` so callers can use it

2. **`run_update_mode(self, download_audio=True, skip_diarization=False, skip_embed=False)`**:
   - Run `run_update_check()` to get the change report
   - If no changes found, print "No new content detected." and return
   - For meetings with new documents (change_type="new_documents"):
     - Call `_ingest_meetings(target_folder=meeting.archive_path, force_update=True)` for each
   - For meetings with new video (change_type="new_video"):
     - If download_audio is True, download audio for those specific meetings using `vimeo_client.download_video()` with the matched video data
     - Process audio (diarize) if not skipped
     - Call `_ingest_meetings(target_folder=meeting.archive_path, force_update=True)` for each
   - After all changed meetings are processed, run `_embed_new_content()` once (unless skip_embed)
   - Print summary: "Update complete: {N} meetings re-processed"

Important notes:
- The `MeetingChange` dataclass should store enough info to drive re-processing (archive_path is critical)
- For video downloads, the `MeetingChange` should carry the Vimeo video_data dict (url, title, uri) so we can download without re-fetching the video map. Store this in a `meta` dict field on MeetingChange.
- Use the same error handling patterns as existing methods (try/except per meeting, continue on error)
  </action>
  <verify>
Run `cd /Users/kyle/development/viewroyal/apps/pipeline && python -c "from pipeline.orchestrator import Archiver; print('Import OK')"` to confirm orchestrator still loads.
  </verify>
  <done>
Archiver has run_update_check() and run_update_mode() methods. run_update_check() prints a report and returns ChangeReport. run_update_mode() selectively re-processes only meetings with detected changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI flags and wire integration + tests</name>
  <files>
    apps/pipeline/main.py
    apps/pipeline/tests/orchestrator/test_orchestrator.py
  </files>
  <action>
**In `main.py`**, add two new CLI arguments:

1. `--check-updates` (action="store_true"): "Check CivicWeb and Vimeo for new content without processing. Prints a report of meetings with changes."

2. `--update-mode` (action="store_true"): "Run in update mode: scrape CivicWeb, check Vimeo, detect changes, and selectively re-process only meetings with new content. Recommended for daily automated runs."

Add handling in the `if __name__ == "__main__"` block, BEFORE the existing `if args.generate_stances:` block:

```python
if args.check_updates:
    print("\n--- Update Check (Dry Run) ---")
    app.run_update_check()
elif args.update_mode:
    print("\n--- Update Mode ---")
    app.run_update_mode(
        download_audio=args.download_audio or True,  # Default to downloading audio in update mode
        skip_diarization=args.skip_diarization,
        skip_embed=args.skip_embed,
    )
```

The `--update-mode` flag should default to downloading audio (since the whole point is to get new video content). But honor `--skip-diarization` and `--skip-embed` if explicitly passed.

**In `tests/orchestrator/test_orchestrator.py`**, add tests:

1. **`test_run_update_check_returns_report`**: Mock the UpdateDetector to return a ChangeReport with some changes. Verify `run_update_check()` returns the report and prints output.

2. **`test_run_update_mode_processes_only_changed_meetings`**: Mock UpdateDetector to return 2 meetings with new docs and 1 with new video. Mock `_ingest_meetings` and `_embed_new_content`. Verify:
   - `_ingest_meetings` is called exactly 3 times (once per changed meeting) with `force_update=True`
   - `_embed_new_content` is called exactly once at the end
   - No other meetings are processed

3. **`test_run_update_mode_no_changes_skips_processing`**: Mock UpdateDetector returning empty report. Verify `_ingest_meetings` is never called.

Follow the existing test patterns: use `mock_orchestrator_deps` fixture, patch at the module level, use `MagicMock`.
  </action>
  <verify>
Run `cd /Users/kyle/development/viewroyal/apps/pipeline && uv run pytest tests/orchestrator/test_orchestrator.py -v -k "update"` and confirm new tests pass.
Also verify `uv run python main.py --help` shows the new flags.
  </verify>
  <done>
`--check-updates` and `--update-mode` flags are visible in `--help`. All new integration tests pass. Running `--check-updates` produces a human-readable report. Running `--update-mode` selectively re-processes only changed meetings.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/kyle/development/viewroyal/apps/pipeline && uv run python main.py --help` shows `--check-updates` and `--update-mode` flags
2. `cd /Users/kyle/development/viewroyal/apps/pipeline && uv run pytest tests/orchestrator/test_orchestrator.py -v -k "update"` -- all update-related tests pass
3. `cd /Users/kyle/development/viewroyal/apps/pipeline && uv run pytest tests/pipeline/test_update_detector.py -v` -- all detector tests still pass (regression)
4. `cd /Users/kyle/development/viewroyal/apps/pipeline && uv run pytest` -- full test suite passes (no regressions)
</verification>

<success_criteria>
- `--check-updates` prints a report of meetings with new documents (DETECT-01) and new video (DETECT-02) without processing anything
- `--update-mode` scrapes, detects, and selectively re-processes only changed meetings (DETECT-03)
- Meetings with no new content are skipped entirely
- After update-mode runs, new content is ingested into the database (visible in web app)
- All tests pass including new ones and existing regression suite
</success_criteria>

<output>
After completion, create `.planning/phases/12-update-detection/12-02-SUMMARY.md`
</output>
