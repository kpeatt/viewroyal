---
phase: 16-core-data-search-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/api/lib/cursor.ts
  - apps/web/app/api/lib/envelope.ts
  - apps/web/app/api/lib/slugs.ts
  - supabase/migrations/add_slug_columns.sql
autonomous: true
requirements: [DATA-11, DATA-12]

must_haves:
  truths:
    - "All list endpoints can encode/decode opaque base64 cursors wrapping sort-value + row ID for keyset pagination"
    - "All responses can be wrapped in a consistent envelope with data, pagination (has_more, next_cursor, per_page), and meta (request_id)"
    - "Every entity table (meetings, people, matters, motions, bylaws, agenda_items) has a populated, indexed, unique slug column"
  artifacts:
    - path: "apps/web/app/api/lib/cursor.ts"
      provides: "Cursor encode/decode and pagination extraction utility"
      exports: ["encodeCursor", "decodeCursor", "extractPage"]
    - path: "apps/web/app/api/lib/envelope.ts"
      provides: "Response envelope builders for list and detail responses"
      exports: ["listResponse", "detailResponse"]
    - path: "apps/web/app/api/lib/slugs.ts"
      provides: "Slug generation functions for all entity types"
      exports: ["slugify", "meetingSlug", "personSlug", "matterSlug", "motionSlug", "bylawSlug", "agendaItemSlug"]
  key_links:
    - from: "apps/web/app/api/lib/envelope.ts"
      to: "requestId middleware"
      via: "c.get('requestId') in meta field"
      pattern: "c\\.get\\(['\"]requestId['\"]\\)"
    - from: "apps/web/app/api/lib/cursor.ts"
      to: "Supabase query builder"
      via: "keyset pagination WHERE clause via .or() filter"
      pattern: "encodeCursor|decodeCursor"
---

<objective>
Create shared pagination, envelope, and slug utilities, plus a database migration to add slug columns to all API-facing entity tables.

Purpose: Every data endpoint in Plans 02-04 depends on these shared utilities. Cursor pagination, response envelopes, and slug-based lookups are cross-cutting concerns that must exist before any endpoint can be built.

Output: Three utility modules (cursor.ts, envelope.ts, slugs.ts) and a Supabase migration adding slug columns to meetings, people, matters, motions, bylaws, and agenda_items.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/16-core-data-search-api/16-RESEARCH.md
@.planning/phases/15-api-foundation/15-01-SUMMARY.md
@.planning/phases/15-api-foundation/15-02-SUMMARY.md
@apps/web/app/api/types.ts
@apps/web/app/api/lib/api-errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cursor pagination, response envelope, and slug generation utilities</name>
  <files>
    apps/web/app/api/lib/cursor.ts
    apps/web/app/api/lib/envelope.ts
    apps/web/app/api/lib/slugs.ts
  </files>
  <action>
Create three utility modules in apps/web/app/api/lib/:

**cursor.ts** -- Cursor encode/decode and page extraction:
- `encodeCursor(payload: { v: string | number; id: number }): string` -- Base64-encode a JSON object containing sort value + row ID. Use `btoa(JSON.stringify(payload))`.
- `decodeCursor(cursor: string): { v: string | number; id: number } | null` -- Decode and parse, return null on failure. Use `atob` + `JSON.parse` wrapped in try/catch.
- `extractPage<T extends { id: number }>(rows: T[], perPage: number, sortKey: keyof T): { data: T[]; has_more: boolean; next_cursor: string | null }` -- Given rows (fetched with perPage + 1 limit), slice to perPage, determine has_more from length > perPage, build next_cursor from last row's sort key value + id.

**envelope.ts** -- Response envelope builders:
- Import `Context` from "hono" and `ApiEnv` from "../types".
- `listResponse<T>(c: Context<ApiEnv>, data: T[], pagination: { has_more: boolean; next_cursor: string | null; per_page: number })` -- Returns `c.json({ data, pagination, meta: { request_id: c.get("requestId") } })`.
- `detailResponse<T>(c: Context<ApiEnv>, data: T)` -- Returns `c.json({ data, meta: { request_id: c.get("requestId") } })`.

**slugs.ts** -- Slug generation for all entity types:
- `slugify(text: string, maxLength = 60): string` -- Lowercase, replace non-alphanumeric with hyphens, trim leading/trailing hyphens, truncate to maxLength, trim trailing hyphen if truncated mid-word. ASCII-only (sufficient for BC civic data).
- `meetingSlug(date: string, type: string): string` -- Returns `{date}-{slugify(type)}`. Example: `2024-01-15-regular-council`.
- `personSlug(name: string): string` -- Returns `slugify(name)`. Example: `david-screech`.
- `matterSlug(id: number, title: string): string` -- Returns `{id}-{slugify(title, 50)}`. Example: `2600-ocp-project-update`.
- `motionSlug(id: number): string` -- Returns `m-{id}`. Motions lack human-readable unique identifiers.
- `bylawSlug(id: number, bylawNumber: string | null, title: string): string` -- If bylawNumber exists, return `slugify(bylawNumber)`. Else return `{id}-{slugify(title, 50)}`.
- `agendaItemSlug(meetingId: number, itemOrder: number, title: string): string` -- Returns `{meetingId}-{itemOrder}-{slugify(title, 40)}`. Example: `42-3-ocp-project-update`. Uses meetingId + itemOrder for uniqueness since agenda_items lack their own municipality_id column.

Use snake_case for all field names in the envelope (per research recommendation -- matches DB columns and civic API conventions). Include null fields explicitly (never omit empty fields).
  </action>
  <verify>Run `cd /Users/kyle/development/viewroyal/apps/web && pnpm typecheck` -- should pass with no errors related to the new files.</verify>
  <done>Three utility modules exist with correct exports, typecheck passes, and all functions use the patterns documented in 16-RESEARCH.md.</done>
</task>

<task type="auto">
  <name>Task 2: Add slug columns to entity tables via Supabase migration</name>
  <files>
    supabase/migrations/add_slug_columns.sql
  </files>
  <action>
Apply a Supabase migration using the MCP `apply_migration` tool (name: `add_slug_columns`) that:

1. **Add slug columns** (nullable initially) to all 6 entity tables:
   - `ALTER TABLE meetings ADD COLUMN IF NOT EXISTS slug text;`
   - `ALTER TABLE people ADD COLUMN IF NOT EXISTS slug text;`
   - `ALTER TABLE matters ADD COLUMN IF NOT EXISTS slug text;`
   - `ALTER TABLE motions ADD COLUMN IF NOT EXISTS slug text;`
   - `ALTER TABLE bylaws ADD COLUMN IF NOT EXISTS slug text;`
   - `ALTER TABLE agenda_items ADD COLUMN IF NOT EXISTS slug text;`

2. **Populate meeting slugs** with duplicate handling (5 known duplicate date+type combos):
   ```sql
   WITH ranked AS (
     SELECT id,
       meeting_date::text || '-' || lower(regexp_replace(type::text, '[^a-zA-Z0-9]+', '-', 'g')) AS base_slug,
       ROW_NUMBER() OVER (PARTITION BY meeting_date, type ORDER BY id) AS rn
     FROM meetings
   )
   UPDATE meetings SET slug = CASE
     WHEN ranked.rn = 1 THEN trim(BOTH '-' FROM ranked.base_slug)
     ELSE trim(BOTH '-' FROM ranked.base_slug) || '-' || ranked.rn
   END
   FROM ranked WHERE meetings.id = ranked.id;
   ```

3. **Populate people slugs** (names are unique):
   ```sql
   UPDATE people SET slug = lower(regexp_replace(trim(name), '[^a-zA-Z0-9]+', '-', 'g'))
   WHERE slug IS NULL;
   ```

4. **Populate matter slugs** (id-prefix for guaranteed uniqueness):
   ```sql
   UPDATE matters SET slug = id::text || '-' || left(lower(regexp_replace(trim(title), '[^a-zA-Z0-9]+', '-', 'g')), 50)
   WHERE slug IS NULL;
   ```
   Then trim trailing hyphens: `UPDATE matters SET slug = rtrim(slug, '-') WHERE slug LIKE '%-';`

5. **Populate motion slugs** (m-{id}):
   ```sql
   UPDATE motions SET slug = 'm-' || id::text WHERE slug IS NULL;
   ```

6. **Populate bylaw slugs** (bylaw_number or id-title):
   ```sql
   UPDATE bylaws SET slug = CASE
     WHEN bylaw_number IS NOT NULL THEN lower(regexp_replace(trim(bylaw_number), '[^a-zA-Z0-9]+', '-', 'g'))
     ELSE id::text || '-' || left(lower(regexp_replace(trim(COALESCE(title, 'bylaw')), '[^a-zA-Z0-9]+', '-', 'g')), 50)
   END
   WHERE slug IS NULL;
   ```
   Then trim trailing hyphens: `UPDATE bylaws SET slug = rtrim(slug, '-') WHERE slug LIKE '%-';`

7. **Populate agenda_item slugs** (meetingId-itemOrder-title):
   ```sql
   UPDATE agenda_items SET slug = meeting_id::text || '-' || COALESCE(item_order, id)::text || '-' || left(lower(regexp_replace(trim(COALESCE(title, 'item')), '[^a-zA-Z0-9]+', '-', 'g')), 40)
   WHERE slug IS NULL;
   ```
   Then trim trailing hyphens: `UPDATE agenda_items SET slug = rtrim(slug, '-') WHERE slug LIKE '%-';`

8. **Set NOT NULL** on all slug columns:
   ```sql
   ALTER TABLE meetings ALTER COLUMN slug SET NOT NULL;
   ALTER TABLE people ALTER COLUMN slug SET NOT NULL;
   ALTER TABLE matters ALTER COLUMN slug SET NOT NULL;
   ALTER TABLE motions ALTER COLUMN slug SET NOT NULL;
   ALTER TABLE bylaws ALTER COLUMN slug SET NOT NULL;
   ALTER TABLE agenda_items ALTER COLUMN slug SET NOT NULL;
   ```

9. **Create unique indexes** â€” scope by municipality_id where the column exists; use globally unique slug where it doesn't. Tables WITHOUT municipality_id: motions (slug m-{id} is globally unique), people (names are unique in single-municipality dataset), agenda_items (scoped by meeting_id prefix in slug). Tables WITH municipality_id: meetings, matters, bylaws.
   ```sql
   CREATE UNIQUE INDEX IF NOT EXISTS idx_meetings_slug_muni ON meetings(slug, municipality_id);
   CREATE UNIQUE INDEX IF NOT EXISTS idx_people_slug ON people(slug);
   CREATE UNIQUE INDEX IF NOT EXISTS idx_matters_slug_muni ON matters(slug, municipality_id);
   CREATE UNIQUE INDEX IF NOT EXISTS idx_motions_slug ON motions(slug);
   CREATE UNIQUE INDEX IF NOT EXISTS idx_bylaws_slug_muni ON bylaws(slug, municipality_id);
   CREATE UNIQUE INDEX IF NOT EXISTS idx_agenda_items_slug ON agenda_items(slug);
   ```

10. **Create triggers** for auto-generating slugs on new inserts (so the pipeline doesn't need changes):
   - Create a function `generate_meeting_slug()` that computes slug from meeting_date + type on INSERT (with duplicate detection via sequence).
   - Create similar trigger functions for people, matters, motions, bylaws, and agenda_items.
   - The agenda_items trigger computes slug from `meeting_id || '-' || item_order || '-' || slugify(title, 40)`.
   - Attach each as a `BEFORE INSERT` trigger that only fires when `NEW.slug IS NULL`.

After applying the migration, verify slug population by querying: `SELECT COUNT(*) FROM meetings WHERE slug IS NOT NULL` (and similar for other tables). All rows should have slugs.

Also write the migration SQL to `supabase/migrations/add_slug_columns.sql` on the local filesystem for source control.
  </action>
  <verify>
Run SQL queries to verify:
- `SELECT COUNT(*) FROM meetings WHERE slug IS NULL` returns 0
- `SELECT COUNT(*) FROM people WHERE slug IS NULL` returns 0
- `SELECT COUNT(*) FROM matters WHERE slug IS NULL` returns 0
- `SELECT COUNT(*) FROM motions WHERE slug IS NULL` returns 0
- `SELECT COUNT(*) FROM bylaws WHERE slug IS NULL` returns 0
- `SELECT COUNT(*) FROM agenda_items WHERE slug IS NULL` returns 0
- `SELECT slug FROM meetings LIMIT 5` shows readable slug format
- `SELECT slug FROM agenda_items LIMIT 5` shows readable slug format
- `SELECT COUNT(*) FROM meetings GROUP BY slug, municipality_id HAVING COUNT(*) > 1` returns 0 (no duplicates)
- `SELECT COUNT(*) FROM motions GROUP BY slug HAVING COUNT(*) > 1` returns 0 (no duplicates -- motions lack municipality_id, slug m-{id} is globally unique)
- `SELECT COUNT(*) FROM people GROUP BY slug HAVING COUNT(*) > 1` returns 0 (no duplicates -- people lack municipality_id, slug is globally unique)
- `SELECT COUNT(*) FROM agenda_items GROUP BY slug HAVING COUNT(*) > 1` returns 0 (no duplicates)
  </verify>
  <done>All 6 entity tables (meetings, people, matters, motions, bylaws, agenda_items) have a populated, NOT NULL, unique slug column with triggers for future inserts. Migration SQL is committed to source control.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes in apps/web/
2. All slug columns populated (0 NULLs across all 6 tables including agenda_items)
3. No duplicate slugs per municipality where municipality_id exists (meetings, matters, bylaws); globally unique where it doesn't (motions, people, agenda_items)
4. cursor.ts, envelope.ts, slugs.ts all export the expected functions
5. Sample slug values are human-readable (e.g., `2024-01-15-regular-council`, `david-screech`)
</verification>

<success_criteria>
- Three shared utility modules exist and typecheck
- All 6 entity tables (including agenda_items) have slug columns with unique indexes
- Insert triggers generate slugs automatically for new rows
- Migration is applied to Supabase and saved to local filesystem
</success_criteria>

<output>
After completion, create `.planning/phases/16-core-data-search-api/16-01-SUMMARY.md`
</output>
