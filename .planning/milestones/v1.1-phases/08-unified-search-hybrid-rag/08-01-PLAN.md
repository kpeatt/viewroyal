---
phase: 08-unified-search-hybrid-rag
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/app/services/hybrid-search.server.ts
  - apps/web/app/lib/intent.ts
requirements:
  - SRCH-03
  - SRCH-04
autonomous: true
must_haves:
  truths:
    - "Hybrid search RPC functions exist in Supabase for motions, key_statements, and document_sections combining vector + FTS with RRF scoring"
    - "key_statements table has a text_search tsvector column with GIN index"
    - "search_results_cache table exists for shareable AI answer URLs"
    - "Intent classifier distinguishes keyword queries from natural language questions"
    - "hybrid-search.server.ts returns unified ranked results across all content types"
  artifacts:
    - path: "apps/web/app/services/hybrid-search.server.ts"
      provides: "Unified hybrid search service calling per-table RPC functions and merging with RRF"
      min_lines: 100
    - path: "apps/web/app/lib/intent.ts"
      provides: "Heuristic query intent classifier (keyword vs question)"
      min_lines: 20
  key_links:
    - from: "apps/web/app/services/hybrid-search.server.ts"
      to: "Supabase hybrid_search_* RPCs"
      via: "supabase.rpc() calls"
      pattern: "supabase\\.rpc\\(\"hybrid_search"
    - from: "apps/web/app/services/hybrid-search.server.ts"
      to: "apps/web/app/lib/embeddings.server.ts"
      via: "generateQueryEmbedding import"
      pattern: "generateQueryEmbedding"
---

<objective>
Create the database foundation and backend search services for Phase 8 unified search.

Purpose: All downstream UI and API work depends on having hybrid search RPCs in Supabase, a unified search service in the web app, and an intent classifier. This plan builds the complete backend layer.

Output: Three Supabase migrations (key_statements tsvector, hybrid search RPCs, cache table), a hybrid-search.server.ts service, and an intent.ts classifier.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-unified-search-hybrid-rag/08-RESEARCH.md

Key existing files to reference:
@apps/web/app/services/vectorSearch.ts
@apps/web/app/services/search.ts
@apps/web/app/lib/embeddings.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase migrations for hybrid search infrastructure</name>
  <files>Supabase migrations (applied via MCP)</files>
  <action>
Apply three Supabase migrations using the MCP supabase tools:

**Migration 1: Add text_search to key_statements**
```sql
ALTER TABLE key_statements ADD COLUMN text_search tsvector
  GENERATED ALWAYS AS (
    to_tsvector('english',
      coalesce(statement_text, '') || ' ' ||
      coalesce(context, '') || ' ' ||
      coalesce(speaker_name, '')
    )
  ) STORED;

CREATE INDEX idx_key_statements_fts ON key_statements USING GIN (text_search);
```

**Migration 2: Create hybrid search RPC functions**
Create three hybrid search functions following the Supabase RRF pattern from 08-RESEARCH.md:

1. `hybrid_search_motions(query_text text, query_embedding halfvec(384), match_count int, full_text_weight float DEFAULT 1, semantic_weight float DEFAULT 1, rrf_k int DEFAULT 50)` -- Returns id, meeting_id, text_content, plain_english_summary, result, mover, seconder, rank_score. Uses `motions.text_search` for FTS and `motions.embedding` for vector. Both CTEs use `LIMIT LEAST(match_count, 30) * 2` for candidate pool.

2. `hybrid_search_key_statements(query_text text, query_embedding halfvec(384), match_count int, full_text_weight float DEFAULT 1, semantic_weight float DEFAULT 1, rrf_k int DEFAULT 50)` -- Returns id, meeting_id, agenda_item_id, speaker_name, statement_type, statement_text, context, rank_score. Uses `key_statements.text_search` (just created) and `key_statements.embedding`.

3. `hybrid_search_document_sections(query_text text, query_embedding halfvec(384), match_count int, full_text_weight float DEFAULT 1, semantic_weight float DEFAULT 1, rrf_k int DEFAULT 50)` -- Returns id, document_id, heading, content (first 500 chars), rank_score. Uses `document_sections.text_search` and `document_sections.embedding`. This table has 0 rows currently but will be populated by Phase 7.1 backfill.

Each function follows the same RRF pattern:
- CTE `full_text`: ROW_NUMBER ordered by ts_rank_cd, filtered by websearch_to_tsquery
- CTE `semantic`: ROW_NUMBER ordered by embedding <=> distance, filtered WHERE embedding IS NOT NULL
- FULL OUTER JOIN on id, compute RRF score: `(COALESCE(1.0/(rrf_k + full_text.rank_ix), 0.0) * full_text_weight + COALESCE(1.0/(rrf_k + semantic.rank_ix), 0.0) * semantic_weight)`
- JOIN back to source table for full columns, ORDER BY rank_score DESC, LIMIT match_count

All functions must include `SET search_path = 'public'` to pass Supabase security advisor.

**Migration 3: Create search_results_cache table**
```sql
CREATE TABLE search_results_cache (
  id text PRIMARY KEY DEFAULT substr(gen_random_uuid()::text, 1, 8),
  query text NOT NULL,
  answer text NOT NULL,
  sources jsonb NOT NULL DEFAULT '[]',
  suggested_followups text[] DEFAULT '{}',
  source_count int DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  expires_at timestamptz DEFAULT now() + interval '30 days'
);

CREATE INDEX idx_search_cache_expires ON search_results_cache(expires_at);

-- Enable RLS but allow public read (cached answers are shareable)
ALTER TABLE search_results_cache ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Anyone can read cached results" ON search_results_cache
  FOR SELECT USING (expires_at > now());
CREATE POLICY "Service role can insert cached results" ON search_results_cache
  FOR INSERT WITH CHECK (true);
```
  </action>
  <verify>
Run `SELECT proname FROM pg_proc WHERE proname LIKE 'hybrid_search_%';` to verify all 3 RPCs exist.
Run `SELECT column_name FROM information_schema.columns WHERE table_name = 'key_statements' AND column_name = 'text_search';` to verify column exists.
Run `SELECT tablename FROM pg_tables WHERE tablename = 'search_results_cache';` to verify cache table exists.
  </verify>
  <done>Three hybrid search RPCs exist and are callable. key_statements has text_search tsvector column with GIN index. search_results_cache table exists with RLS policies.</done>
</task>

<task type="auto">
  <name>Task 2: Create hybrid search service and intent classifier</name>
  <files>apps/web/app/services/hybrid-search.server.ts, apps/web/app/lib/intent.ts</files>
  <action>
**Create `apps/web/app/lib/intent.ts`:**

Implement a heuristic intent classifier that distinguishes keyword queries from natural language questions. Follow the pattern from 08-RESEARCH.md:

```typescript
const QUESTION_STARTERS = [
  'who', 'what', 'when', 'where', 'why', 'how',
  'is', 'are', 'was', 'were', 'do', 'does', 'did',
  'can', 'could', 'will', 'would', 'should', 'has', 'have',
  'tell me', 'explain', 'describe', 'compare',
];

export type QueryIntent = 'question' | 'keyword';

export function classifyIntent(query: string): QueryIntent {
  // 1. Ends with ? -> question
  // 2. Starts with question word -> question
  // 3. Multi-word phrases starting with question patterns -> question
  // 4. Short queries (1-3 words, no verb) -> keyword
  // 5. Longer queries (5+ words) without markers -> default to question (ambiguous default per user decision)
  // 6. Default (4 words): question (ambiguous -> AI per user decision)
}
```

Export both `classifyIntent` and `QueryIntent`.

**Create `apps/web/app/services/hybrid-search.server.ts`:**

This is the unified search service replacing the old `search.ts` and `vectorSearch.ts`. It should:

1. Export a `UnifiedSearchResult` interface:
```typescript
export interface UnifiedSearchResult {
  id: number;
  type: 'motion' | 'key_statement' | 'document_section' | 'transcript_segment';
  title: string;
  content: string;          // Preview text (first 200 chars)
  meeting_id: number | null;
  meeting_date: string | null;
  speaker_name?: string;
  rank_score: number;
  // Type-specific metadata
  motion_result?: string;
  motion_mover?: string;
  motion_seconder?: string;
  statement_type?: string;
  start_time?: number;
}
```

2. Export a `hybridSearchAll` function:
```typescript
export async function hybridSearchAll(
  query: string,
  options?: {
    types?: ('motion' | 'key_statement' | 'document_section' | 'transcript_segment')[];
    limit?: number;
  }
): Promise<UnifiedSearchResult[]>
```

This function should:
- Generate a query embedding using `generateQueryEmbedding` from embeddings.server.ts
- Call the three hybrid search RPCs in parallel (motions, key_statements, document_sections) using `getSupabaseAdminClient()` from supabase.server.ts
- For transcript_segments, use FTS-only search (no embeddings exist) via a direct Supabase query with `.textSearch('text_search', tsQuery)`, enriched with meeting data. Limit to 15 results.
- Normalize all results into `UnifiedSearchResult[]`
- Sort by rank_score descending (for hybrid results) and interleave transcript results based on a comparable score
- For transcript FTS results, assign a synthetic rank_score based on ts_rank normalized to 0-1 range
- Apply type filter if specified
- Return top N results (default 30)

3. Export `getSearchResultCache` and `saveSearchResultCache` functions:
```typescript
export async function getSearchResultCache(id: string): Promise<CachedResult | null>
export async function saveSearchResultCache(data: { query: string; answer: string; sources: any[]; suggested_followups: string[]; source_count: number }): Promise<string>
```

Use `getSupabaseAdminClient()` for these (service role key to bypass RLS for inserts).

For the hybrid RPC calls, pass the embedding as `JSON.stringify(embedding)` (matching existing pattern in vectorSearch.ts).

Import pattern:
- `generateQueryEmbedding` from `../lib/embeddings.server`
- `getSupabaseAdminClient` from `../lib/supabase.server`
  </action>
  <verify>
Run `cd /Users/kyle/development/viewroyal/apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to verify TypeScript compiles without errors in the new files. The pre-existing error in voice-fingerprints.tsx line 404 is expected and should be ignored.
  </verify>
  <done>hybrid-search.server.ts exports hybridSearchAll, UnifiedSearchResult, getSearchResultCache, and saveSearchResultCache. intent.ts exports classifyIntent and QueryIntent. Both compile without new TypeScript errors.</done>
</task>

</tasks>

<verification>
1. All three Supabase migrations applied successfully
2. `hybrid_search_motions`, `hybrid_search_key_statements`, `hybrid_search_document_sections` RPCs exist and are callable
3. `key_statements.text_search` column exists with GIN index
4. `search_results_cache` table exists with RLS
5. `hybrid-search.server.ts` compiles and exports expected functions
6. `intent.ts` compiles and exports classifier
</verification>

<success_criteria>
- Three new Supabase RPC functions implement hybrid search with RRF across motions, key_statements, and document_sections
- key_statements table has text_search tsvector for full-text search
- search_results_cache table ready for shareable URLs
- hybrid-search.server.ts provides unified search API for the frontend
- intent.ts classifies queries as keyword or question
- No new TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-unified-search-hybrid-rag/08-01-SUMMARY.md`
</output>
