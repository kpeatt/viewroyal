---
phase: 16-core-data-search-api
plan: 04
type: execute
wave: 3
depends_on: ["16-02", "16-03"]
files_modified:
  - apps/web/app/api/serializers/search.ts
  - apps/web/app/api/endpoints/search.ts
  - apps/web/app/api/index.ts
autonomous: true
requirements: [SRCH-01, SRCH-02, SRCH-03]

must_haves:
  truths:
    - "API consumer can search across all content types via GET /api/v1/:municipality/search?q= and receive results with content type, relevance score, and text snippets"
    - "Search results are paginated with per_page and page-based offset"
    - "Search results are filterable by content type via ?type= query parameter"
    - "Keyword search (tsvector-based) works for all API key holders without additional credentials"
  artifacts:
    - path: "apps/web/app/api/serializers/search.ts"
      provides: "Search result serializer"
      exports: ["serializeSearchResult"]
    - path: "apps/web/app/api/endpoints/search.ts"
      provides: "SearchEndpoint chanfana endpoint class"
      exports: ["SearchEndpoint"]
  key_links:
    - from: "apps/web/app/api/endpoints/search.ts"
      to: "Supabase tsvector search"
      via: "ts_rank_cd keyword search on motions, matters, agenda_items, key_statements, document_sections via RPC or raw SQL"
      pattern: "ts_rank_cd|rpc\\(|websearch_to_tsquery"
    - from: "apps/web/app/api/endpoints/search.ts"
      to: "apps/web/app/api/lib/envelope.ts"
      via: "listResponse for search results"
      pattern: "listResponse"
    - from: "apps/web/app/api/index.ts"
      to: "apps/web/app/api/endpoints/search.ts"
      via: "route registration"
      pattern: "SearchEndpoint"
---

<objective>
Implement the cross-entity search endpoint with keyword (tsvector) search across all content types, type filtering, relevance scoring, text snippets, and page-based pagination.

Purpose: Search is the highest-value API feature for consumers who want to find specific civic data without knowing which entity table to query. The keyword tier (available to all API key holders) leverages existing Postgres tsvector indexes for fast, relevant results.

Output: 1 search result serializer, 1 chanfana search endpoint, and updated route registration.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/16-core-data-search-api/16-RESEARCH.md
@.planning/phases/16-core-data-search-api/16-02-SUMMARY.md
@.planning/phases/16-core-data-search-api/16-03-SUMMARY.md
@apps/web/app/api/index.ts
@apps/web/app/api/types.ts
@apps/web/app/api/lib/envelope.ts
@apps/web/app/services/hybrid-search.server.ts
@apps/web/app/services/search.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search result serializer and search endpoint</name>
  <files>
    apps/web/app/api/serializers/search.ts
    apps/web/app/api/endpoints/search.ts
  </files>
  <action>
**search serializer (serializers/search.ts):**
- `serializeSearchResult(row)` -- Returns: `{ type (content type: "motion", "matter", "agenda_item", "key_statement", "document_section"), slug (entity slug for linking), title (entity title or contextual title), snippet (content text truncated to 200 chars at word boundary with ellipsis), score (ts_rank relevance score as number), meeting_slug (if applicable, null otherwise), meeting_date (if applicable, null otherwise) }`.
- The serializer must handle different source shapes since results come from multiple tables.

**search endpoint (endpoints/search.ts -- SearchEndpoint):**

Schema request.query:
- `q` (required string, min 1 char) -- search query text
- `type` (optional string) -- comma-separated content type filter. Valid types: `motions`, `matters`, `agenda_items`, `key_statements`, `document_sections`. Multiple types: `?type=motions,matters`.
- `per_page` (coerce number, default 20, max 100)
- `page` (coerce number, default 1, min 1) -- page-based offset for search (NOT cursor-based, per research recommendation: search results are inherently volatile and cursor pagination over merged results is awkward)

Handler implementation:

1. **Parse query into tsquery:** Use `websearch_to_tsquery('english', q)` via Supabase RPC or raw SQL. If the query is empty or produces an empty tsquery, return empty results.

2. **Determine content types to search:** If `type` param provided, parse comma-separated values and validate against allowed types. Default: search all 5 types.

3. **Run parallel keyword searches** using `Promise.all()` across selected content types. For each type, use Supabase `.textSearch()` with the `text_search` tsvector column:

   - **motions:** `supabase.from("motions").select("id, slug, text_content, plain_english_summary, text_search, meetings!inner(slug, meeting_date)").textSearch("text_search", q, { type: "websearch" }).eq("municipality_id", muni.id).limit(perTypeLimit)`
   - **matters:** `supabase.from("matters").select("id, slug, title, description, plain_english_summary, text_search").textSearch("text_search", q, { type: "websearch" }).eq("municipality_id", muni.id).limit(perTypeLimit)`
   - **agenda_items:** `supabase.from("agenda_items").select("id, slug, title, plain_english_summary, debate_summary, text_search, meetings!inner(slug, meeting_date)").textSearch("text_search", q, { type: "websearch" }).eq("municipality_id", muni.id).limit(perTypeLimit)`
   - **key_statements:** `supabase.from("key_statements").select("id, statement_text, context, speaker_name, text_search, meetings!inner(slug, meeting_date)").textSearch("text_search", q, { type: "websearch" }).eq("municipality_id", muni.id).limit(perTypeLimit)` -- Note: key_statements may not have slug column; use meeting_slug + index as identifier.
   - **document_sections:** `supabase.from("document_sections").select("id, section_title, section_text, text_search, extracted_documents!inner(meetings!inner(slug, meeting_date))").textSearch("text_search", q, { type: "websearch" }).eq("municipality_id", muni.id).limit(perTypeLimit)` -- Note: document_sections may not have slug column; check schema and adapt.

   Set `perTypeLimit` to `per_page * 2` (fetch more from each type to have enough after merge + sort).

4. **Merge and rank results:** Combine all results into a unified array. Each result MUST have a meaningful `score` derived from `ts_rank` (SRCH-02 requires relevance scoring). Sort all results by score DESC.

   **Concrete approach for ts_rank:** The Supabase `.textSearch()` method does NOT return rank scores. Instead, use `supabase.rpc()` to call a lightweight keyword-search RPC for each content type, or use raw SQL via `supabase.rpc('exec_sql', ...)`. The recommended pattern follows the existing `hybrid_search_motions` RPC (see `hybrid-search.server.ts`), which uses `ts_rank_cd()` to compute relevance.

   **Implementation:** For each content type, write inline SQL executed via `supabase.rpc()` or create a single `keyword_search` RPC during Plan 16-01 migration. The SQL pattern for each type:
   ```sql
   SELECT id, slug, title_or_text_field,
          ts_rank_cd(text_search, websearch_to_tsquery('english', $1)) AS score
   FROM table_name
   WHERE text_search @@ websearch_to_tsquery('english', $1)
     AND municipality_id = $2  -- where applicable; for motions join via meetings
   ORDER BY score DESC
   LIMIT $3
   ```
   If creating an RPC is preferred (cleaner), add a `keyword_search_all` RPC in Plan 16-01 that accepts (query_text, municipality_id, content_types[], match_count) and returns a UNION of ranked results across all requested types. Either approach is acceptable as long as every result has a real ts_rank score.

   **Do NOT use a fallback score of 1.0.** Every result must have a computed relevance score from ts_rank_cd.

5. **Paginate merged results:** Apply page-based offset: `const start = (page - 1) * per_page; const pageResults = merged.slice(start, start + per_page);`. Determine `has_more = merged.length > start + per_page`.

6. **Serialize and return:** Map through `serializeSearchResult`. Return via `listResponse` with pagination: `{ has_more, next_cursor: null, per_page }`. Add `page` to pagination object as well for consumer convenience.

**Handling missing slug columns on key_statements and document_sections:**
- key_statements likely don't have slugs (they weren't in the migration since they're not a top-level API entity). For search results, use the meeting_slug as the linking slug and include statement index or ID.
- document_sections similarly lack slugs. Use meeting_slug for linking.
- The `type` field in the search result tells consumers what kind of entity the result is and how to follow up (e.g., fetch the parent meeting by meeting_slug).

**Scope note:** Only implement keyword search (tsvector) in this plan. Hybrid/semantic search requires "bring your own embedding key" which adds complexity. The keyword tier fulfills SRCH-01 requirements. The hybrid tier can be added in a gap closure plan if needed.
  </action>
  <verify>Run `cd /Users/kyle/development/viewroyal/apps/web && pnpm typecheck` -- should pass.</verify>
  <done>Search serializer and endpoint exist, typecheck passes. Endpoint searches across multiple content types using tsvector, merges results, and returns paginated results with type, score, and snippet fields.</done>
</task>

<task type="auto">
  <name>Task 2: Register search route in Hono app</name>
  <files>
    apps/web/app/api/index.ts
  </files>
  <action>
Update `apps/web/app/api/index.ts` to register the search endpoint.

1. Import: `import { SearchEndpoint } from "./endpoints/search";`

2. Register route with middleware:
   ```typescript
   // Search
   app.use("/api/v1/:municipality/search", apiKeyAuth, rateLimit, municipality);
   openapi.get("/api/v1/:municipality/search", SearchEndpoint);
   ```

3. Add after all entity routes (meetings, people, matters, motions, bylaws).

4. Keep all existing routes unchanged.
  </action>
  <verify>Run `cd /Users/kyle/development/viewroyal/apps/web && pnpm typecheck` -- passes. Verify index.ts imports SearchEndpoint and registers the search route pair.</verify>
  <done>Search endpoint registered at /api/v1/:municipality/search with auth + rate-limit + municipality middleware. Typecheck passes.</done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes in apps/web/
2. search.ts serializer and endpoint exist with correct exports
3. index.ts registers the search route with proper middleware chain
4. Search endpoint accepts `q`, `type`, `per_page`, `page` query parameters
5. Results include `type`, `slug`, `title`, `snippet`, `score`, `meeting_slug`, `meeting_date`
6. Type filtering works (comma-separated content types)
7. Page-based pagination returns correct slices with has_more indicator
</verification>

<success_criteria>
- GET /api/v1/:municipality/search?q=housing returns results from multiple content types
- GET /api/v1/:municipality/search?q=housing&type=motions returns only motion results
- Results include content type, relevance score, and 200-char text snippets
- Pagination with per_page and page parameters works correctly
- Empty query or no results returns { data: [], pagination: { has_more: false, ... } }
</success_criteria>

<output>
After completion, create `.planning/phases/16-core-data-search-api/16-04-SUMMARY.md`
</output>
