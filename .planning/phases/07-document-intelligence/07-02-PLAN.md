---
phase: 07-document-intelligence
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - apps/web/app/lib/types.ts
  - apps/web/app/services/meetings.ts
  - apps/web/app/components/meeting/DocumentSections.tsx
  - apps/web/app/components/meeting/AgendaOverview.tsx
  - apps/web/app/routes/meeting-detail.tsx
  - apps/pipeline/main.py
  - apps/pipeline/pipeline/orchestrator.py
autonomous: true
requirements:
  - DOC-05

must_haves:
  truths:
    - "Meeting detail page shows document sections as expandable accordions under their linked agenda items"
    - "Original PDF link is preserved alongside parsed sections (not replaced)"
    - "Section titles are visible without expanding; clicking expands to show full section text"
    - "Running --backfill-sections processes existing documents into sections with embeddings"
    - "Backfill skips documents that already have sections (idempotent) unless --force flag is used"
    - "Backfill uses two-pass approach: create all sections first, then generate embeddings"
  artifacts:
    - path: "apps/web/app/components/meeting/DocumentSections.tsx"
      provides: "Accordion display component for document sections"
      min_lines: 30
    - path: "apps/web/app/lib/types.ts"
      provides: "DocumentSection TypeScript interface"
      contains: "DocumentSection"
    - path: "apps/web/app/services/meetings.ts"
      provides: "getDocumentSections query function"
      contains: "getDocumentSections"
    - path: "apps/pipeline/main.py"
      provides: "--backfill-sections CLI flag"
      contains: "backfill-sections"
    - path: "apps/pipeline/pipeline/orchestrator.py"
      provides: "backfill_document_sections() method"
      contains: "backfill_document_sections"
  key_links:
    - from: "apps/web/app/routes/meeting-detail.tsx"
      to: "apps/web/app/services/meetings.ts"
      via: "getDocumentSections() call in loader"
      pattern: "getDocumentSections"
    - from: "apps/web/app/components/meeting/AgendaOverview.tsx"
      to: "apps/web/app/components/meeting/DocumentSections.tsx"
      via: "DocumentSections component rendered in expanded content"
      pattern: "DocumentSections"
    - from: "apps/pipeline/main.py"
      to: "apps/pipeline/pipeline/orchestrator.py"
      via: "--backfill-sections flag triggers backfill_document_sections()"
      pattern: "backfill_document_sections"
---

<objective>
Add document sections display to the meeting detail page and create the backfill CLI command for processing existing documents.

Purpose: Users need to see parsed document content directly on meeting pages (not just PDF links), and all 7+ existing documents need to be retroactively sectioned with embeddings. This plan delivers both the web UI and the backfill tooling.

Output: DocumentSections accordion component on meeting pages. `--backfill-sections` CLI flag with `--force` option and two-pass approach.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-document-intelligence/07-RESEARCH.md
@.planning/phases/07-document-intelligence/07-CONTEXT.md
@.planning/phases/07-document-intelligence/07-01-SUMMARY.md
@apps/web/app/components/meeting/AgendaOverview.tsx
@apps/web/app/routes/meeting-detail.tsx
@apps/web/app/services/meetings.ts
@apps/web/app/lib/types.ts
@apps/pipeline/main.py
@apps/pipeline/pipeline/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DocumentSection type, service, and accordion UI on meeting pages</name>
  <files>
    apps/web/app/lib/types.ts
    apps/web/app/services/meetings.ts
    apps/web/app/components/meeting/DocumentSections.tsx
    apps/web/app/components/meeting/AgendaOverview.tsx
    apps/web/app/routes/meeting-detail.tsx
  </files>
  <action>
**1. Add DocumentSection interface to `apps/web/app/lib/types.ts`:**

```typescript
export interface DocumentSection {
  id: number;
  document_id: number;
  agenda_item_id: number | null;
  section_title: string | null;
  section_text: string;
  section_order: number;
  page_start: number | null;
  page_end: number | null;
  token_count: number | null;
}
```

Add after the existing interfaces (after SpeakerAlias or Topic interface).

**2. Add `getDocumentSections()` to `apps/web/app/services/meetings.ts`:**

```typescript
export async function getDocumentSections(
  supabase: SupabaseClient,
  meetingId: string
): Promise<DocumentSection[]> {
  const { data, error } = await supabase
    .from("document_sections")
    .select("id, document_id, agenda_item_id, section_title, section_text, section_order, page_start, page_end, token_count")
    .eq("document_id.meeting_id", meetingId)  // This won't work - need a different approach
    ...
```

Actually, since document_sections doesn't have a direct meeting_id, we need to join through documents. Use a two-step approach:
- In the meeting-detail loader, after fetching the meeting, also fetch document sections by first getting document IDs for this meeting, then fetching their sections. OR use a Supabase query with inner join.

Better approach — use Supabase's relational query:
```typescript
export async function getDocumentSectionsForMeeting(
  supabase: SupabaseClient,
  meetingId: string
): Promise<DocumentSection[]> {
  // First get document IDs for this meeting
  const { data: docs } = await supabase
    .from("documents")
    .select("id")
    .eq("meeting_id", meetingId);

  if (!docs || docs.length === 0) return [];

  const docIds = docs.map(d => d.id);
  const { data, error } = await supabase
    .from("document_sections")
    .select("id, document_id, agenda_item_id, section_title, section_text, section_order, page_start, page_end, token_count")
    .in("document_id", docIds)
    .order("document_id", { ascending: true })
    .order("section_order", { ascending: true });

  if (error) {
    console.error("Error fetching document sections:", error);
    return [];
  }
  return data ?? [];
}
```

Import DocumentSection type in the service file.

**3. Create `apps/web/app/components/meeting/DocumentSections.tsx`:**

An accordion component that displays document sections. Uses the existing CSS grid-rows animation pattern from `collapsible-section.tsx`.

```tsx
import { useState } from "react";
import { FileText, ChevronDown } from "lucide-react";
import { cn } from "../../lib/utils";
import type { DocumentSection } from "../../lib/types";

interface DocumentSectionsProps {
  sections: DocumentSection[];
}

export function DocumentSections({ sections }: DocumentSectionsProps) {
  const [expandedId, setExpandedId] = useState<number | null>(null);

  if (sections.length === 0) return null;

  return (
    <div className="space-y-1">
      <h4 className="flex items-center gap-2 text-xs font-bold text-zinc-500 uppercase tracking-wider">
        <FileText className="w-3 h-3 text-indigo-500" />
        Document Sections ({sections.length})
      </h4>
      <div className="pl-5 space-y-1">
        {sections.map((section) => (
          <div key={section.id} className="border border-zinc-100 rounded-lg overflow-hidden">
            <button
              onClick={() => setExpandedId(expandedId === section.id ? null : section.id)}
              className="w-full flex items-center justify-between px-3 py-2 text-left hover:bg-zinc-50 transition-colors"
            >
              <span className="text-sm font-medium text-zinc-700 truncate pr-2">
                {section.section_title || `Section ${section.section_order}`}
              </span>
              <ChevronDown
                className={cn(
                  "w-4 h-4 text-zinc-400 flex-shrink-0 transition-transform",
                  expandedId === section.id && "rotate-180"
                )}
              />
            </button>
            <div
              className={cn(
                "grid transition-all duration-200 ease-in-out",
                expandedId === section.id ? "grid-rows-[1fr]" : "grid-rows-[0fr]"
              )}
            >
              <div className="overflow-hidden">
                <div className="px-3 pb-3 border-t border-zinc-100">
                  <p className="text-sm text-zinc-600 leading-relaxed whitespace-pre-line mt-2">
                    {section.section_text}
                  </p>
                  {section.page_start != null && (
                    <span className="text-[10px] text-zinc-400 mt-2 block">
                      Page {section.page_start}{section.page_end && section.page_end !== section.page_start ? `–${section.page_end}` : ""}
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

**4. Integrate into `AgendaOverview.tsx`:**

- Add `documentSections` prop to `AgendaOverviewProps` and `AgendaItemRowProps` (type: `DocumentSection[]`)
- In the `AgendaItemRow` expanded content area, AFTER the Motions section and BEFORE the Keywords section (around line 570), add:

```tsx
{/* Document Sections */}
{linkedSections.length > 0 && (
  <DocumentSections sections={linkedSections} />
)}
```

Where `linkedSections` is filtered from the full sections list: `const linkedSections = documentSections.filter(s => s.agenda_item_id === item.id);`

Import `DocumentSections` and `DocumentSection` type at the top.

Pass `documentSections` through from `AgendaOverview` to each `AgendaItemRow`.

**5. Update meeting-detail.tsx loader:**

In the loader function, add a call to `getDocumentSectionsForMeeting()` alongside the existing parallel fetches. Add the result to the returned data object as `documentSections`.

In the component, pass `documentSections` to `AgendaOverview`:
```tsx
<AgendaOverview
  items={agendaItems}
  documentSections={documentSections}
  expandedItemId={...}
  ...
/>
```

Import `getDocumentSectionsForMeeting` from the services file.

**Key user decisions honored:**
- Sections displayed as expandable accordions under agenda items (locked decision)
- Section titles visible, click to expand content (locked decision)
- Original PDF link preserved alongside parsed sections (locked decision) — no changes to existing document/PDF display
  </action>
  <verify>
1. `grep "DocumentSection" apps/web/app/lib/types.ts` — confirms interface exists
2. `grep "getDocumentSectionsForMeeting" apps/web/app/services/meetings.ts` — confirms service function exists
3. `ls apps/web/app/components/meeting/DocumentSections.tsx` — confirms component exists
4. `grep "documentSections" apps/web/app/components/meeting/AgendaOverview.tsx` — confirms prop integration
5. `grep "documentSections" apps/web/app/routes/meeting-detail.tsx` — confirms loader integration
6. `cd apps/web && pnpm typecheck` — no new type errors (ignore pre-existing voice-fingerprints.tsx error)
  </verify>
  <done>Meeting detail pages display document sections as expandable accordions under their linked agenda items. Section titles are visible; clicking expands to show full text. Original PDF links remain untouched.</done>
</task>

<task type="auto">
  <name>Task 2: Add --backfill-sections CLI flag with two-pass backfill</name>
  <files>
    apps/pipeline/main.py
    apps/pipeline/pipeline/orchestrator.py
  </files>
  <action>
**1. Add `--backfill-sections` and `--force` flags to `apps/pipeline/main.py`:**

Add two new arguments to the argparse parser:

```python
parser.add_argument(
    "--backfill-sections",
    action="store_true",
    help="Backfill document sections for all existing documents (two-pass: sections first, embeddings second).",
)

parser.add_argument(
    "--force",
    action="store_true",
    help="Force re-processing (delete and recreate existing data). Used with --backfill-sections.",
)
```

Add a new elif branch in the main execution flow (after the existing `elif args.embed_only:` block, before `elif args.process_only`):

```python
elif args.backfill_sections:
    print("\n--- Backfill Document Sections ---")
    app.backfill_document_sections(force=args.force)
    if not args.skip_embed:
        print("\n--- Embedding Document Sections ---")
        app._embed_new_content()
```

This implements the two-pass approach: `backfill_document_sections()` creates all sections first (pass 1), then `_embed_new_content()` generates embeddings for the new rows (pass 2). If embedding fails partway, sections are already in the DB and `--embed-only` can be run separately to resume.

**2. Add `backfill_document_sections()` method to `Archiver` class in `apps/pipeline/pipeline/orchestrator.py`:**

```python
def backfill_document_sections(self, force=False):
    """Backfill document_sections for all existing documents.

    Two-pass approach per user decision:
    Pass 1 (this method): Create sections for all documents
    Pass 2 (called separately): _embed_new_content() generates embeddings

    Idempotent: skips documents that already have sections unless force=True.
    Parse errors: logs and skips, continues with remaining documents.
    """
    from pipeline.ingestion.document_chunker import chunk_document, link_sections_to_agenda_items

    supabase_key = config.SUPABASE_SECRET_KEY or config.SUPABASE_KEY
    if not config.SUPABASE_URL or not supabase_key:
        print("  [!] SUPABASE_URL/KEY not set, skipping backfill.")
        return

    supabase = create_client(config.SUPABASE_URL, supabase_key)
    municipality_id = self.municipality.id if self.municipality else 1

    # Fetch all documents with file paths
    result = supabase.table("documents").select(
        "id, meeting_id, title, file_path"
    ).eq("municipality_id", municipality_id).execute()

    documents = result.data or []
    print(f"  Found {len(documents)} documents to process")

    if not documents:
        print("  [!] No documents found. Run pipeline ingestion first.")
        return

    processed = 0
    skipped = 0
    errors = 0

    for doc in documents:
        doc_id = doc["id"]
        meeting_id = doc["meeting_id"]
        title = doc["title"] or f"Document {doc_id}"
        file_path = doc.get("file_path")

        if not file_path:
            skipped += 1
            continue

        # Check idempotency (skip if sections exist, unless force)
        if not force:
            existing = supabase.table("document_sections").select(
                "id", count="exact"
            ).eq("document_id", doc_id).execute()
            if existing.count and existing.count > 0:
                skipped += 1
                continue

        # If force, delete existing sections first
        if force:
            supabase.table("document_sections").delete().eq(
                "document_id", doc_id
            ).execute()

        # Resolve full PDF path
        # Documents store relative paths like "Agenda/filename.pdf"
        # Meeting archive_path gives the base folder
        meeting_result = supabase.table("meetings").select(
            "archive_path"
        ).eq("id", meeting_id).single().execute()

        if not meeting_result.data or not meeting_result.data.get("archive_path"):
            print(f"  [!] No archive_path for meeting {meeting_id}, skipping {title}")
            skipped += 1
            continue

        archive_path = meeting_result.data["archive_path"]
        # archive_path may be relative to ARCHIVE_ROOT or absolute
        if not os.path.isabs(archive_path):
            archive_path = os.path.join(self.archive_root, archive_path)

        pdf_path = os.path.join(archive_path, file_path)
        if not os.path.exists(pdf_path):
            print(f"  [!] PDF not found: {pdf_path}, skipping {title}")
            skipped += 1
            continue

        # Chunk the document
        try:
            sections = chunk_document(pdf_path, title)
        except Exception as e:
            print(f"  [!] Error chunking {title}: {e}")
            errors += 1
            continue

        if not sections:
            skipped += 1
            continue

        # Link to agenda items
        try:
            sections = link_sections_to_agenda_items(sections, meeting_id, supabase)
        except Exception as e:
            print(f"  [!] Error linking sections for {title}: {e}")
            # Continue without links — sections are still valuable

        # Insert sections
        try:
            rows = []
            for s in sections:
                rows.append({
                    "document_id": doc_id,
                    "agenda_item_id": s.get("agenda_item_id"),
                    "section_title": s.get("section_title"),
                    "section_text": s["section_text"],
                    "section_order": s["section_order"],
                    "page_start": s.get("page_start"),
                    "page_end": s.get("page_end"),
                    "token_count": s.get("token_count"),
                    "municipality_id": municipality_id,
                })
            supabase.table("document_sections").insert(rows).execute()
            processed += 1
            print(f"  [+] {title}: {len(sections)} sections")
        except Exception as e:
            print(f"  [!] Error inserting sections for {title}: {e}")
            errors += 1

    print(f"\n  Backfill complete: {processed} documents sectioned, {skipped} skipped, {errors} errors")
```

Add `import os` at the top of orchestrator.py if not already present (it is — line 2).

**Important:** The `_embed_new_content()` call in main.py after `backfill_document_sections()` handles pass 2 automatically because `document_sections` is now in TABLE_CONFIG (from Plan 01). The `embed_table()` function only embeds rows where `embedding IS NULL`, so it will pick up all newly-created sections.
  </action>
  <verify>
1. `grep "backfill-sections" apps/pipeline/main.py` — confirms CLI flag exists
2. `grep "backfill_document_sections" apps/pipeline/pipeline/orchestrator.py` — confirms method exists
3. `cd apps/pipeline && uv run python main.py --help` — shows --backfill-sections in help output
4. Verify two-pass structure: `grep -A5 "backfill_sections" apps/pipeline/main.py` — shows sections first, then embed
  </verify>
  <done>--backfill-sections CLI flag exists and triggers two-pass backfill (sections first, embeddings second). Idempotent by default (skips docs with existing sections). --force deletes and recreates sections. Parse errors are logged and skipped. Progress is reported per document.</done>
</task>

</tasks>

<verification>
1. DocumentSection interface exists in types.ts
2. getDocumentSectionsForMeeting function queries sections for a meeting
3. DocumentSections.tsx renders expandable accordions with CSS grid-rows animation
4. AgendaOverview shows linked sections in expanded agenda item content
5. meeting-detail.tsx loader fetches and passes document sections
6. --backfill-sections flag triggers backfill_document_sections() in orchestrator
7. Backfill is idempotent (skip-if-exists) with --force override
8. Two-pass approach: sections created first, embeddings generated second
9. `pnpm typecheck` passes (ignoring pre-existing voice-fingerprints.tsx error)
</verification>

<success_criteria>
- Meeting detail page shows document section accordions under linked agenda items
- Section titles visible without expanding; click expands to show full text
- Original PDF links remain untouched (sections are additive)
- `uv run python main.py --backfill-sections` processes existing documents
- `uv run python main.py --backfill-sections --force` recreates all sections
- Backfill + embed generates halfvec(384) embeddings for all sections
</success_criteria>

<output>
After completion, create `.planning/phases/07-document-intelligence/07-02-SUMMARY.md`
</output>
