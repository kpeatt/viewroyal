---
phase: 15-api-foundation
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified:
  - supabase/migrations/create_api_keys.sql
  - apps/web/app/api/lib/api-key.ts
  - apps/web/app/api/middleware/auth.ts
  - apps/web/app/api/middleware/rate-limit.ts
  - apps/web/app/api/endpoints/test-auth.ts
  - apps/web/app/api/index.ts
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "An API consumer can authenticate by passing a valid key in the X-API-Key header"
    - "An API consumer can authenticate by passing a valid key in the ?apikey query parameter"
    - "A request with no API key receives 401 with MISSING_API_KEY error"
    - "A request with an invalid API key receives 401 with INVALID_API_KEY error"
    - "API keys are stored as SHA-256 hashes in the database, never as raw keys"
    - "Key comparison uses timing-safe equality to prevent timing attacks"
    - "Rate limiting is enforced per-key using Cloudflare Workers Rate Limit binding"
    - "A rate-limited request receives HTTP 429 with Retry-After header"
    - "The health endpoint remains unauthenticated"
  artifacts:
    - path: "supabase/migrations/create_api_keys.sql"
      provides: "api_keys table with user_id FK, key_hash, key_prefix, is_active, timestamps"
      contains: "CREATE TABLE"
    - path: "apps/web/app/api/lib/api-key.ts"
      provides: "hashApiKey() and timingSafeCompare() functions"
      exports: ["hashApiKey", "timingSafeCompare", "generateApiKey"]
    - path: "apps/web/app/api/middleware/auth.ts"
      provides: "apiKeyAuth Hono middleware"
      exports: ["apiKeyAuth"]
    - path: "apps/web/app/api/middleware/rate-limit.ts"
      provides: "rateLimit Hono middleware using CF Rate Limit binding"
      exports: ["rateLimit"]
    - path: "apps/web/app/api/endpoints/test-auth.ts"
      provides: "Authenticated test endpoint to verify auth + rate limiting work"
  key_links:
    - from: "apps/web/app/api/middleware/auth.ts"
      to: "apps/web/app/api/lib/api-key.ts"
      via: "hashApiKey() and timingSafeCompare() for key validation"
      pattern: "hashApiKey|timingSafeCompare"
    - from: "apps/web/app/api/middleware/auth.ts"
      to: "apps/web/app/lib/supabase.server.ts"
      via: "getSupabaseAdminClient() to query api_keys table"
      pattern: "getSupabaseAdminClient.*api_keys"
    - from: "apps/web/app/api/middleware/rate-limit.ts"
      to: "wrangler.toml [[ratelimits]]"
      via: "c.env.API_RATE_LIMITER.limit() binding"
      pattern: "API_RATE_LIMITER\\.limit"
    - from: "apps/web/app/api/index.ts"
      to: "apps/web/app/api/middleware/auth.ts"
      via: "middleware applied to authenticated route group"
      pattern: "apiKeyAuth"
---

<objective>
Implement API key authentication and durable rate limiting, completing the API foundation. Creates the api_keys database table, SHA-256 key hashing utilities, auth middleware, rate-limit middleware, and an authenticated test endpoint that verifies the full auth + rate limit stack works end-to-end.

Purpose: After this plan, the API infrastructure is complete -- all subsequent phases (16-18) can focus purely on data endpoints, knowing that auth, rate limiting, errors, CORS, and municipality scoping are handled.

Output: Working API key authentication with timing-safe comparison, durable per-key rate limiting via Cloudflare Workers Rate Limit binding, and a test endpoint at `/api/v1/{municipality}/test` that requires a valid API key.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-api-foundation/15-RESEARCH.md
@.planning/phases/15-api-foundation/15-01-SUMMARY.md

@apps/web/app/api/index.ts
@apps/web/app/api/types.ts
@apps/web/app/api/lib/api-errors.ts
@apps/web/app/lib/supabase.server.ts
@apps/web/wrangler.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create api_keys table and seed a test key</name>
  <files>
    supabase/migrations/create_api_keys.sql
    apps/web/app/api/lib/api-key.ts
  </files>
  <action>
**First, create the API key utility file** `apps/web/app/api/lib/api-key.ts`:

`hashApiKey(key: string): Promise<string>` — Uses `crypto.subtle.digest("SHA-256", ...)` to hash the key. Returns the hash as a lowercase hex string. Uses TextEncoder to encode the string to bytes, then converts the ArrayBuffer to hex via `Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, "0")).join("")`.

`timingSafeCompare(a: string, b: string): Promise<boolean>` — Hashes BOTH input strings with SHA-256 first (producing fixed 32-byte buffers), then compares with `crypto.subtle.timingSafeEqual()`. This is critical because `timingSafeEqual` throws on length mismatch, and double-hashing guarantees equal-length buffers. See research Pitfall 2.

`generateApiKey(): string` — Generates a cryptographically random API key. Uses `crypto.getRandomValues(new Uint8Array(32))` and returns `"vr_" + hex`. Result is 67 chars: 3 prefix + 64 hex. The "vr_" prefix makes keys visually identifiable.

**Then, create the migration** `supabase/migrations/create_api_keys.sql`:

```sql
-- API Keys table for public API authentication
CREATE TABLE IF NOT EXISTS api_keys (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  key_hash text NOT NULL,
  key_prefix varchar(8) NOT NULL,
  name text NOT NULL DEFAULT 'Default',
  is_active boolean NOT NULL DEFAULT true,
  last_used_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Index on prefix for fast lookup (auth middleware queries by prefix first)
CREATE INDEX IF NOT EXISTS idx_api_keys_prefix_active ON api_keys(key_prefix, is_active) WHERE is_active = true;

-- Index on user_id for listing a user's keys
CREATE INDEX IF NOT EXISTS idx_api_keys_user_id ON api_keys(user_id);

-- Enable RLS
ALTER TABLE api_keys ENABLE ROW LEVEL SECURITY;

-- Users can read their own keys
CREATE POLICY "Users can view own keys" ON api_keys
  FOR SELECT USING (auth.uid() = user_id);

-- Users can insert their own keys
CREATE POLICY "Users can create own keys" ON api_keys
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Users can update (deactivate) their own keys
CREATE POLICY "Users can update own keys" ON api_keys
  FOR UPDATE USING (auth.uid() = user_id);

-- Service role bypasses RLS (used by auth middleware)
```

**Apply the migration** using the Supabase MCP tool `apply_migration` with name "create_api_keys" and the SQL above.

**Then seed a test API key.** Generate a test key using the `generateApiKey()` function logic. The seed process:
1. Compute the SHA-256 hash of a known test key value
2. Insert a row into api_keys with:
   - user_id: pick an existing auth user (query auth.users to find one, or use a hardcoded admin user ID if one exists in the project)
   - key_hash: the SHA-256 hex hash
   - key_prefix: first 8 chars of the raw key
   - name: "Test Key (Development)"

For the seed, we need to compute the hash. Since we can't run the TypeScript function directly in SQL, use pgcrypto:
```sql
-- Seed a development test key
-- Raw key: vr_testkey_development_00000000000000000000000000000000
-- (This is for development only -- never use predictable keys in production)
INSERT INTO api_keys (user_id, key_hash, key_prefix, name)
SELECT
  id,
  encode(sha256(convert_to('vr_testkey_development_00000000000000000000000000000000', 'UTF8')), 'hex'),
  'vr_testk',
  'Development Test Key'
FROM auth.users
LIMIT 1
ON CONFLICT DO NOTHING;
```

Execute the seed SQL via `execute_sql` (not apply_migration, since it's data not DDL).

NOTE: If there are no auth.users in the database, the INSERT will simply insert 0 rows. That's fine -- the test key is a development convenience, not a hard requirement. Document the raw test key value in the plan SUMMARY so the user knows what to use for testing.
  </action>
  <verify>
Verify the table exists:
```sql
SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'api_keys' ORDER BY ordinal_position;
```

Verify the seed key (if users exist):
```sql
SELECT id, key_prefix, name, is_active FROM api_keys LIMIT 5;
```
  </verify>
  <done>api_keys table exists with proper schema (id, user_id FK, key_hash, key_prefix, name, is_active, last_used_at, timestamps). RLS policies allow users to manage their own keys. A development test key is seeded if auth users exist.</done>
</task>

<task type="auto">
  <name>Task 2: Create auth and rate-limit middleware, wire into Hono app with test endpoint</name>
  <files>
    apps/web/app/api/middleware/auth.ts
    apps/web/app/api/middleware/rate-limit.ts
    apps/web/app/api/endpoints/test-auth.ts
    apps/web/app/api/index.ts
  </files>
  <action>
**`app/api/middleware/auth.ts`** — API key authentication middleware using `createMiddleware<ApiEnv>`:
1. Extract API key from `c.req.header("X-API-Key")` OR `c.req.query("apikey")` (header takes priority)
2. If no key found, throw `ApiError(401, "MISSING_API_KEY", "API key required. Pass via X-API-Key header or ?apikey query parameter.")`
3. Hash the provided key using `hashApiKey()` from `../lib/api-key`
4. Extract prefix: `apiKey.substring(0, 8)`
5. Query `api_keys` table via `getSupabaseAdminClient()`: `.from("api_keys").select("id, user_id, key_hash, is_active").eq("key_prefix", prefix).eq("is_active", true).maybeSingle()`
6. If no record found OR `timingSafeCompare(keyHash, keyRecord.key_hash)` returns false, throw `ApiError(401, "INVALID_API_KEY", "Invalid API key. Check your key and try again.")`
7. On success: `c.set("apiKeyId", keyRecord.id)` and `c.set("userId", keyRecord.user_id)`
8. Optionally update `last_used_at` in the background using `c.executionCtx?.waitUntil()` or just skip this for now (performance concern on every request)
9. Call `await next()`

Import `getSupabaseAdminClient` from `~/lib/supabase.server`. Import `hashApiKey` and `timingSafeCompare` from `../lib/api-key`. Import `ApiError` from `../lib/api-errors`.

**`app/api/middleware/rate-limit.ts`** — Rate limiting middleware using `createMiddleware<ApiEnv>`:
1. Get `apiKeyId` from `c.get("apiKeyId")` (set by auth middleware, which runs first)
2. Call `c.env.API_RATE_LIMITER.limit({ key: \`api:\${apiKeyId}\` })`
3. If `!success`, throw `ApiError(429, "RATE_LIMIT_EXCEEDED", "Rate limit exceeded. Please wait before making more requests.", { "Retry-After": "60" })`
4. Add `X-RateLimit-Limit: 100` header to response via `c.header("X-RateLimit-Limit", "100")`
5. Call `await next()`

**`app/api/endpoints/test-auth.ts`** — A chanfana `OpenAPIRoute` class for testing the auth + rate limit stack:
- Path: `/api/v1/:municipality/test`
- Summary: "Test authenticated endpoint"
- Description: "Returns API key info and municipality context. Requires valid API key."
- `handle()` returns: `{ authenticated: true, apiKeyId: c.get("apiKeyId"), municipality: c.get("municipality")?.name, requestId: c.get("requestId") }`
- This endpoint exists purely for Phase 15 verification. It can be removed or kept as a debug tool.

**Update `app/api/index.ts`**:
1. Import auth middleware, rate-limit middleware, and test-auth endpoint
2. Create an "authenticated" route group for municipality-scoped routes that require auth. Use Hono's chained middleware pattern:
   ```
   // Authenticated, rate-limited, municipality-scoped routes
   openapi.get("/api/v1/:municipality/test", TestAuthEndpoint);
   ```
3. Apply the auth and rate-limit middleware to the `:municipality` routes that need authentication. The pattern:
   - For routes needing auth: apply `apiKeyAuth` then `rateLimit` then `resolveMunicipality` as middleware BEFORE the endpoint
   - For the health endpoint: NO auth middleware (already set up in Plan 01)

   Use Hono's `app.use("/api/v1/:municipality/*", apiKeyAuth, rateLimit, resolveMunicipality)` pattern to apply middleware to all municipality-scoped routes. Then REMOVE the per-route municipality middleware from the health endpoint route (since it's now applied globally to the pattern).

   BUT the health endpoint should NOT require auth. Solution: register the health endpoint at `/api/v1/:municipality/health` BEFORE the global middleware, or use a more specific path pattern for the auth middleware. Alternative approach: register health endpoints outside the authenticated group, and use an explicit middleware chain for authenticated routes.

   **Recommended approach:** Do NOT use `app.use()` for blanket middleware on `:municipality/*`. Instead, for each authenticated endpoint, apply middleware explicitly per-route or in a route group. This gives fine-grained control. The pattern:
   ```typescript
   // Unauthenticated routes (from Plan 01)
   openapi.get("/api/v1/health", HealthEndpoint);
   // Municipality-scoped health also unauthenticated -- apply only municipality middleware
   // (Already done in Plan 01)

   // Authenticated route group: auth -> rate limit -> municipality
   const authed = new Hono<ApiEnv>();
   authed.use("*", apiKeyAuth, rateLimit, resolveMunicipality);
   openapi.get("/api/v1/:municipality/test", TestAuthEndpoint);
   // ... future endpoints go here
   ```

   Actually, the cleanest pattern with chanfana is to apply Hono middleware at a path level that excludes health, then register chanfana endpoints separately. Use:
   ```typescript
   // Apply auth + rate limit to all municipality routes EXCEPT health
   app.use("/api/v1/:municipality/*", async (c, next) => {
     // Skip auth for health endpoint
     if (c.req.path.endsWith("/health")) {
       return next();
     }
     // Chain: auth -> rate limit -> municipality
     return apiKeyAuth(c, async () => rateLimit(c, async () => resolveMunicipality(c, next)));
   });
   ```

   OR more simply: apply municipality middleware to ALL municipality routes, and auth + rate limit only to non-health ones:
   ```typescript
   // Municipality resolution for all /:municipality/* routes
   app.use("/api/v1/:municipality/*", resolveMunicipality);

   // Auth + rate limit for everything except health under /:municipality/
   app.use("/api/v1/:municipality/test", apiKeyAuth, rateLimit);
   // (In future phases, add more specific paths or a broader pattern excluding health)
   ```

   Use whichever pattern produces the cleanest code. The critical constraints are:
   - Health endpoint: NO auth required, municipality middleware applied
   - Test endpoint: auth + rate limit + municipality middleware all applied
   - Future data endpoints (Phase 16+): auth + rate limit + municipality middleware

4. Register the test-auth endpoint with chanfana: `openapi.get("/api/v1/:municipality/test", TestAuthEndpoint)`
  </action>
  <verify>
Run `cd apps/web && pnpm typecheck` and `pnpm build` to verify everything compiles.

Then verify the migration was applied:
```sql
SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'api_keys';
```

Then run existing tests to confirm no regressions: `cd apps/web && pnpm test -- --run`
  </verify>
  <done>
Auth middleware extracts API key from X-API-Key header or ?apikey query param, hashes with SHA-256, looks up by prefix, timing-safe compares full hash. Rate limit middleware uses c.env.API_RATE_LIMITER.limit() with per-key scoping. Test endpoint at /api/v1/{municipality}/test requires valid API key and returns auth context. Health endpoint remains unauthenticated. Build and typecheck pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `pnpm build` succeeds in apps/web/
2. `pnpm typecheck` succeeds in apps/web/
3. api_keys table exists in Supabase with correct schema
4. The Worker can be started locally and:
   - GET /api/v1/view-royal/test WITHOUT API key returns 401 `{ error: { code: "MISSING_API_KEY", ... } }`
   - GET /api/v1/view-royal/test with invalid API key returns 401 `{ error: { code: "INVALID_API_KEY", ... } }`
   - GET /api/v1/view-royal/test with valid test API key returns 200 `{ authenticated: true, apiKeyId: "...", municipality: "View Royal", requestId: "..." }`
   - GET /api/v1/health still works without any API key (unauthenticated)
   - GET /api/v1/view-royal/health still works without any API key (unauthenticated)
   - 429 responses include Retry-After header (tested by exceeding rate limit)
5. `pnpm test` passes (existing tests still work)
</verification>

<success_criteria>
- API key authentication works via both X-API-Key header and ?apikey query param
- Keys are stored as SHA-256 hashes, compared with timing-safe equality
- Rate limiting uses Cloudflare Workers Rate Limit binding (durable across isolate eviction)
- 429 responses include Retry-After header
- Health endpoint remains unauthenticated
- Test endpoint requires valid API key and returns auth context
- api_keys table has proper schema with RLS policies
- No regressions to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/15-api-foundation/15-02-SUMMARY.md`
</output>
