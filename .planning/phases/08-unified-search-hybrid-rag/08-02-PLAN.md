---
phase: 08-unified-search-hybrid-rag
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - apps/web/app/routes/api.search.tsx
  - apps/web/app/services/rag.server.ts
requirements:
  - SRCH-02
  - SRCH-04
autonomous: true
must_haves:
  truths:
    - "GET /api/search?q=... returns streaming SSE with AI answer events when query is a question"
    - "GET /api/search?q=...&mode=keyword returns JSON search results when query is a keyword lookup"
    - "RAG agent can search document_sections in addition to existing content types"
    - "Completed AI answers are cached to search_results_cache with a short ID"
    - "GET /api/search?id=abc123 returns cached AI answer without re-generating"
  artifacts:
    - path: "apps/web/app/routes/api.search.tsx"
      provides: "Unified search API with streaming AI answers and keyword results"
      min_lines: 80
    - path: "apps/web/app/services/rag.server.ts"
      provides: "Updated RAG agent with document_sections search tool"
      contains: "search_document_sections"
  key_links:
    - from: "apps/web/app/routes/api.search.tsx"
      to: "apps/web/app/services/hybrid-search.server.ts"
      via: "hybridSearchAll import"
      pattern: "hybridSearchAll"
    - from: "apps/web/app/routes/api.search.tsx"
      to: "apps/web/app/services/rag.server.ts"
      via: "runQuestionAgent import"
      pattern: "runQuestionAgent"
    - from: "apps/web/app/routes/api.search.tsx"
      to: "apps/web/app/lib/intent.ts"
      via: "classifyIntent import"
      pattern: "classifyIntent"
---

<objective>
Create the unified search API route and enhance the RAG agent with document sections support.

Purpose: The search page needs a single API endpoint that handles both keyword search results (JSON) and AI-powered answers (streaming SSE). The RAG agent needs to search document_sections alongside existing content types. Completed answers are cached for shareable URLs.

Output: A new api.search.tsx route and an updated rag.server.ts with document_sections tool.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-unified-search-hybrid-rag/08-RESEARCH.md
@.planning/phases/08-unified-search-hybrid-rag/08-01-SUMMARY.md

Key existing files:
@apps/web/app/routes/api.ask.tsx
@apps/web/app/services/rag.server.ts
@apps/web/app/services/hybrid-search.server.ts
@apps/web/app/lib/intent.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unified search API route</name>
  <files>apps/web/app/routes/api.search.tsx</files>
  <action>
Create `apps/web/app/routes/api.search.tsx` as a resource route (no default export). This is the single API endpoint for the unified search page.

Register the route in `apps/web/app/routes.ts` by adding: `route("api/search", "routes/api.search.tsx"),` after the existing api routes.

The route should handle GET requests in its `loader` function with the following behavior:

**Query parameters:**
- `q` (required): The search query
- `mode` (optional): Force `keyword` or `ai` mode. If omitted, use `classifyIntent(q)` to auto-detect.
- `context` (optional): Previous Q&A context for follow-up questions
- `id` (optional): Cached result ID for shareable URLs

**Flow:**

1. If `id` is provided (no `q` needed), look up cached result via `getSearchResultCache(id)`. Return JSON with the cached answer, sources, and suggested_followups. Return 404 if not found or expired.

2. If `q` is provided:
   a. Determine mode: if `mode` param is set, use it. Otherwise, call `classifyIntent(q)`.
   b. If mode is `keyword`: call `hybridSearchAll(q)` and return JSON response with results array.
   c. If mode is `question` (or `ai`): create a streaming SSE response using the existing ReadableStream pattern from `api.ask.tsx`.

**For streaming AI answers (mode=question):**
- Reuse the exact ReadableStream + TextEncoder SSE pattern from api.ask.tsx (NOT remix-utils EventEmitter)
- Reuse the rate limiting logic from api.ask.tsx (copy the isRateLimited, getClientIP functions)
- Get municipality name via `createSupabaseServerClient` + `getMunicipality`
- Call `runQuestionAgent(question, context, undefined, municipalityName)`
- Stream all events (tool_call, tool_observation, final_answer_chunk, sources, done)
- On "done" event, also emit a `cache_id` event with the cached result ID:
  - After streaming completes, collect the full answer text and sources
  - Call `saveSearchResultCache({ query, answer, sources, suggested_followups: [], source_count: sources.length })`
  - Emit `{ type: "cache_id", id: cacheId }` before the "done" event

**For keyword results (mode=keyword):**
- Call `hybridSearchAll(q, { types: filterTypes, limit: 30 })`
- Parse `type` query params for filtering (e.g., `?type=motion&type=transcript_segment`)
- Return `Response.json({ results, query, intent: 'keyword' })`

**Important implementation notes:**
- Import `classifyIntent` from `../lib/intent`
- Import `hybridSearchAll, getSearchResultCache, saveSearchResultCache` from `../services/hybrid-search.server`
- Import `runQuestionAgent, type AgentEvent` from `../services/rag.server`
- Import `createSupabaseServerClient` from `../lib/supabase.server`
- Import `getMunicipality` from `../services/municipality`
- The SSE streaming pattern MUST use `new ReadableStream({ async start(controller) { ... } })` -- this is the only pattern that works on Cloudflare Workers
- Rate limit: 10 requests per minute per IP (same as api.ask.tsx)
  </action>
  <verify>
Run `cd /Users/kyle/development/viewroyal/apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to verify no new TypeScript errors.
Verify the route is registered: `grep 'api/search' apps/web/app/routes.ts`
  </verify>
  <done>api.search.tsx handles both keyword (JSON) and AI answer (streaming SSE) modes. Rate limiting applied. Cached results retrievable by ID. Route registered in routes.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Add document_sections search tool to RAG agent</name>
  <files>apps/web/app/services/rag.server.ts</files>
  <action>
Update `apps/web/app/services/rag.server.ts` to add a `search_document_sections` tool to the RAG agent's tool list.

**Add the search function (above the `tools` array):**

```typescript
async function search_document_sections({
  query,
  after_date,
}: {
  query: string;
  after_date?: string;
}): Promise<any[]> {
  const embedding = await generateQueryEmbedding(query);
  if (!embedding) return [];

  try {
    const { data } = await getSupabase().rpc("hybrid_search_document_sections", {
      query_text: query,
      query_embedding: JSON.stringify(embedding),
      match_count: 15,
      full_text_weight: 1,
      semantic_weight: 1,
      rrf_k: 50,
    });

    if (!data || data.length === 0) return [];

    // Enrich with document and meeting info
    const docIds = [...new Set(data.map((d: any) => d.document_id))];

    let enrichQuery = getSupabase()
      .from("documents")
      .select(`
        id,
        title,
        meeting_id,
        meetings!inner(meeting_date)
      `)
      .in("id", docIds);

    if (after_date) {
      enrichQuery = enrichQuery.gte("meetings.meeting_date", after_date);
    }

    const { data: docs } = await enrichQuery;
    const docMap = new Map((docs || []).map((d: any) => [d.id, d]));

    return data
      .filter((d: any) => {
        const doc = docMap.get(d.document_id);
        return doc !== undefined; // Filter out sections from docs excluded by date
      })
      .map((d: any) => {
        const doc = docMap.get(d.document_id);
        const meeting = Array.isArray(doc?.meetings) ? doc.meetings[0] : doc?.meetings;
        return {
          id: d.id,
          document_id: d.document_id,
          heading: d.heading,
          content: d.content,
          meeting_id: doc?.meeting_id || 0,
          document_title: doc?.title || "Unknown",
          meeting_date: meeting?.meeting_date || "Unknown",
        };
      });
  } catch (error) {
    console.error("Document section search failed:", error);
    return [];
  }
}
```

**Add to the tools array:**
```typescript
{
  name: "search_document_sections",
  description:
    'search_document_sections(query: string, after_date?: string) — Searches PDF document sections by hybrid search (semantic + keyword). Returns section headings and content from council documents like staff reports, bylaws, policies. Good for finding specific details from official documents that may not appear in meeting transcripts. after_date filters to results on or after that date (YYYY-MM-DD format).',
  call: async ({ query, after_date }: { query: string; after_date?: string }) =>
    search_document_sections({ query, after_date }),
},
```

**Add normalizer function:**
```typescript
function normalizeDocumentSectionSources(sections: any[]): NormalizedSource[] {
  return sections.map((s) => ({
    type: "document_section" as const,
    id: s.id,
    meeting_id: s.meeting_id || 0,
    meeting_date: s.meeting_date || "Unknown",
    title: `[Doc] ${s.heading || s.document_title || "Document Section"}`,
  }));
}
```

**Update the NormalizedSource type union** to include `"document_section"`:
Change `type: "transcript" | "motion" | "vote" | "key_statement" | "matter" | "agenda_item"` to `type: "transcript" | "motion" | "vote" | "key_statement" | "matter" | "agenda_item" | "document_section"`.

**Add source collection in the agent loop** (in the section that collects normalized sources based on tool type):
After the `search_key_statements` check, add:
```typescript
else if (tool_name === "search_document_sections") {
  allSources.push(...normalizeDocumentSectionSources(toolResult));
}
```

**Update the orchestrator system prompt** to mention the new tool in the strategy section:
Add to the tool descriptions: `- \`search_document_sections\` — Best for finding specific details from official PDF documents like staff reports, bylaws, and policy documents. Use when the user asks about specific document content or when other tools don't provide enough detail.`

**Also update the tool strategy guidance** in the system prompt to mention document sections:
Under "Choose the right tool for the job", add guidance for when to use search_document_sections.
  </action>
  <verify>
Run `cd /Users/kyle/development/viewroyal/apps/web && npx tsc --noEmit --pretty 2>&1 | head -30` to verify no new TypeScript errors.
Verify the tool is registered: `grep 'search_document_sections' apps/web/app/services/rag.server.ts`
  </verify>
  <done>RAG agent has search_document_sections tool that uses the new hybrid search RPC. NormalizedSource type includes document_section. Orchestrator prompt guides when to use the new tool.</done>
</task>

</tasks>

<verification>
1. `api.search.tsx` route exists and is registered in routes.ts
2. GET /api/search?q=test&mode=keyword returns JSON with results
3. GET /api/search?q=what+did+council+decide returns streaming SSE
4. GET /api/search?id=nonexistent returns 404
5. rag.server.ts includes search_document_sections in tools array
6. NormalizedSource type includes document_section
7. No new TypeScript compilation errors
</verification>

<success_criteria>
- Single API endpoint handles both keyword search (JSON) and AI answers (streaming SSE)
- Intent auto-detection routes queries to the correct mode
- Cached AI results are stored and retrievable by ID
- RAG agent can search document sections alongside existing content types
- Rate limiting protects the AI endpoint
- All code compiles without new TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-unified-search-hybrid-rag/08-02-SUMMARY.md`
</output>
