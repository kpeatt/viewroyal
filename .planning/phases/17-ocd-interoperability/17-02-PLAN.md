---
phase: 17-ocd-interoperability
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - apps/web/app/api/ocd/serializers/jurisdiction.ts
  - apps/web/app/api/ocd/serializers/organization.ts
  - apps/web/app/api/ocd/serializers/person.ts
  - apps/web/app/api/ocd/endpoints/jurisdictions.ts
  - apps/web/app/api/ocd/endpoints/organizations.ts
  - apps/web/app/api/ocd/endpoints/people.ts
  - apps/web/app/api/ocd/router.ts
  - apps/web/app/api/index.ts
autonomous: true
requirements: [OCD-01, OCD-02, OCD-03]

must_haves:
  truths:
    - "API consumer can GET /api/ocd/:municipality/jurisdictions and receive a list of OCD Jurisdiction objects"
    - "API consumer can GET /api/ocd/:municipality/jurisdictions/:id and receive a single OCD Jurisdiction"
    - "API consumer can GET /api/ocd/:municipality/organizations and receive paginated OCD Organization objects"
    - "API consumer can GET /api/ocd/:municipality/organizations/:id and receive a single OCD Organization with posts"
    - "API consumer can GET /api/ocd/:municipality/people and receive paginated OCD Person objects"
    - "API consumer can GET /api/ocd/:municipality/people/:id and receive a single OCD Person with memberships"
    - "All responses include all OCD spec fields (null when empty)"
    - "OCD endpoints are publicly accessible without API key authentication"
    - "List endpoints return OpenStates-format pagination with page, per_page, max_page, total_items"
  artifacts:
    - path: "apps/web/app/api/ocd/router.ts"
      provides: "OCD sub-router with municipality middleware and all route registrations"
      min_lines: 30
    - path: "apps/web/app/api/ocd/serializers/jurisdiction.ts"
      provides: "Municipality to OCD Jurisdiction mapping"
      exports: ["serializeJurisdiction"]
    - path: "apps/web/app/api/ocd/serializers/organization.ts"
      provides: "Organization to OCD Organization mapping"
      exports: ["serializeOrganizationSummary", "serializeOrganizationDetail"]
    - path: "apps/web/app/api/ocd/serializers/person.ts"
      provides: "Person to OCD Person mapping"
      exports: ["serializePersonSummary", "serializePersonDetail"]
    - path: "apps/web/app/api/ocd/endpoints/jurisdictions.ts"
      provides: "Jurisdiction list and detail handlers"
      exports: ["listJurisdictions", "getJurisdiction"]
    - path: "apps/web/app/api/ocd/endpoints/organizations.ts"
      provides: "Organization list and detail handlers"
      exports: ["listOrganizations", "getOrganization"]
    - path: "apps/web/app/api/ocd/endpoints/people.ts"
      provides: "People list and detail handlers"
      exports: ["listPeople", "getPerson"]
  key_links:
    - from: "apps/web/app/api/ocd/router.ts"
      to: "apps/web/app/api/index.ts"
      via: "app.route('/api/ocd', ocdApp)"
      pattern: "app\\.route.*ocd"
    - from: "apps/web/app/api/ocd/endpoints/jurisdictions.ts"
      to: "apps/web/app/api/ocd/serializers/jurisdiction.ts"
      via: "import serializeJurisdiction"
      pattern: "serializeJurisdiction"
    - from: "apps/web/app/api/ocd/serializers/person.ts"
      to: "apps/web/app/api/ocd/lib/ocd-ids.ts"
      via: "import ocdPersonId for ID generation"
      pattern: "ocdPersonId"
---

<objective>
Build OCD Jurisdiction, Organization, and Person serializers and endpoints, create the OCD sub-router, and mount it in the main Hono app. These are the simpler OCD entities with less nested related data.

Purpose: Deliver the first three OCD entity types with full spec compliance. Jurisdiction and Organization are small datasets (1 and 10 rows respectively). Person is larger (837 rows) but has straightforward field mapping. Creates the router infrastructure that Plan 03 extends with Event, Bill, and Vote.

Output: Six new endpoint files, three serializer files, one router, and a modified index.ts.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-ocd-interoperability/17-RESEARCH.md
@.planning/phases/17-ocd-interoperability/17-01-SUMMARY.md

# Existing API patterns
@apps/web/app/api/index.ts
@apps/web/app/api/types.ts
@apps/web/app/api/middleware/municipality.ts
@apps/web/app/api/serializers/meeting.ts
@apps/web/app/api/endpoints/meetings/list.ts
@apps/web/app/api/endpoints/meetings/detail.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jurisdiction, Organization, and Person serializers</name>
  <files>
    apps/web/app/api/ocd/serializers/jurisdiction.ts
    apps/web/app/api/ocd/serializers/organization.ts
    apps/web/app/api/ocd/serializers/person.ts
  </files>
  <action>
Create three serializer modules following the allowlist pattern from the existing v1 serializers (never spread `...row`, always construct explicitly, include all spec fields even when null).

**jurisdiction.ts** -- Map municipality + organizations to OCD Jurisdiction:
- `serializeJurisdiction(municipality: any, organizations: any[], divisionId: string)` returns:
  ```
  {
    id: ocdJurisdictionId(csdCode),  // extracted from divisionId
    name: municipality.name,
    url: municipality.website_url ?? null,
    classification: "government",
    division: { id: divisionId, name: municipality.short_name ?? municipality.name },
    legislative_sessions: [],  // View Royal has no formal sessions; empty array per research recommendation
    feature_flags: [],
    extras: {},  // Empty per user decision (strict spec compliance, no extras)
    created_at: municipality.created_at ?? null,
    updated_at: municipality.created_at ?? null,
    sources: [{ url: municipality.website_url ?? "", note: null }]
  }
  ```
- Note: `ocdJurisdictionId` is synchronous (not UUID-based), so this serializer can be sync.

**organization.ts** -- Map organization rows to OCD Organization:
- `serializeOrganizationSummary(org: any, ocdId: string, jurisdictionId: string)` -- lightweight list view:
  ```
  {
    id: ocdId,
    name: org.name,
    classification: mapClassification(org.classification),  // Council -> legislature, Committee -> committee, etc.
    jurisdiction_id: jurisdictionId,
    parent_id: null,  // Set to Council's OCD ID for committees if org.parent_organization_id exists; null otherwise
    image: null,
    extras: {},
    created_at: org.created_at ?? null,
    updated_at: org.created_at ?? null,
    sources: []
  }
  ```
- `serializeOrganizationDetail(org: any, ocdId: string, jurisdictionId: string, memberships: any[], memberOcdIds: Map<number, string>)` -- full detail with posts/memberships:
  ```
  {
    ...summary fields,
    links: [],
    contact_details: [],
    posts: memberships.map(m => ({
      id: null,
      label: m.role ?? "Member",
      role: m.role ?? "member",
      organization_id: ocdId,
      division_id: null,
      start_date: m.start_date ?? null,
      end_date: m.end_date ?? null,
      person: m.person ? { id: memberOcdIds.get(m.person.id) ?? null, name: m.person.name } : null
    }))
  }
  ```
- `mapClassification(dbClassification: string): string` -- helper mapping: `Council` -> `legislature`, `Committee` -> `committee`, `Board` -> `commission`, default -> `committee`.

**person.ts** -- Map people rows to OCD Person:
- `serializePersonSummary(person: any, ocdId: string)` -- lightweight list view:
  ```
  {
    id: ocdId,
    name: person.name,
    sort_name: person.name ?? null,  // Use name as sort_name (no separate sort field in DB)
    family_name: null,  // Not available in DB
    given_name: null,   // Not available in DB
    image: person.image_url ?? null,
    gender: null,
    birth_date: null,
    death_date: null,
    extras: {},
    created_at: person.created_at ?? null,
    updated_at: person.created_at ?? null,
    sources: []
  }
  ```
- `serializePersonDetail(person: any, ocdId: string, memberships: any[], orgOcdIds: Map<number, string>)` -- full detail:
  ```
  {
    ...summary fields,
    identifiers: [],
    other_names: [],
    links: [],
    contact_details: person.email ? [{ type: "email", value: person.email, note: null, label: null }] : [],
    memberships: memberships.map(m => ({
      organization: m.organization ? { id: orgOcdIds.get(m.organization.id) ?? null, name: m.organization.name, classification: mapClassification(m.organization.classification) } : null,
      role: m.role ?? "member",
      label: m.role ?? "Member",
      start_date: m.start_date ?? null,
      end_date: m.end_date ?? null,
      person_id: ocdId
    }))
  }
  ```

All serializers import from `../lib/ocd-ids` for ID generation. Use JSDoc comments matching existing serializer style.
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | grep -E "ocd/serializers" | head -20` to check for TypeScript errors.
  </verify>
  <done>
Three OCD serializer modules exist with full spec field coverage. Every OCD field is present in the output (null when empty). No `...row` spreading. Classification mapping works for Council/Committee/Board types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Jurisdiction, Organization, and Person endpoints with OCD router</name>
  <files>
    apps/web/app/api/ocd/endpoints/jurisdictions.ts
    apps/web/app/api/ocd/endpoints/organizations.ts
    apps/web/app/api/ocd/endpoints/people.ts
    apps/web/app/api/ocd/router.ts
    apps/web/app/api/index.ts
  </files>
  <action>
Create endpoint handlers as plain Hono handler functions (NOT chanfana OpenAPIRoute classes -- OCD endpoints have their own spec and don't need OpenAPI generation per RESEARCH.md).

**jurisdictions.ts** -- List and detail handlers:
- `listJurisdictions` handler: Query `municipalities` table filtered by `c.get("municipality").id`. Since there's only 1 municipality, return it as a single-item list. Use `serializeJurisdiction`. Return with `ocdListResponse` (pagination: page 1, per_page 1, max_page 1, total_items 1).
- `getJurisdiction` handler: Accept `:id` param. Parse the jurisdiction ID. Query municipality and verify it matches. If the ID is the jurisdiction's OCD ID, return the full jurisdiction. Otherwise return 404 using `ApiError`. Return with `ocdDetailResponse`.
- Both handlers query the `ocd_divisions` table to get the division_id for the municipality.

**organizations.ts** -- List and detail handlers:
- `listOrganizations` handler: Query `organizations` table filtered by municipality_id. Use `parsePaginationParams` for page/per_page. Use `.select("*", { count: "exact" })` to get total count alongside data. Apply offset/limit: `.range(offset, offset + perPage - 1)`. Pre-compute OCD IDs using `ocdIds("organization", pks)`. Serialize with `serializeOrganizationSummary`. Return with `ocdListResponse`.
- `getOrganization` handler: Accept `:id` param. Extract the UUID from the OCD ID path (strip `ocd-organization/` prefix). Since we can't reverse a UUID v5 to get the PK, instead fetch ALL organizations for the municipality (only ~10 rows), compute their OCD IDs, and find the matching one. Fetch memberships for the matching org. Return with `ocdDetailResponse`.
- This lookup-by-OCD-ID pattern is acceptable because the organization dataset is tiny (10 rows).

**people.ts** -- List and detail handlers:
- `listPeople` handler: Query `people` joined through `memberships` -> `organizations` to scope to municipality. Use `parsePaginationParams`. Use `.select("id, name, image_url, email, slug, is_councillor, created_at", { count: "exact" })`. Pre-compute OCD IDs. Serialize with `serializePersonSummary`. Return with `ocdListResponse`.
- `getPerson` handler: Accept `:id` param. Same OCD ID reverse-lookup approach but for people (837 rows -- slightly larger). Fetch the person + memberships. Alternative approach: since people are scoped via memberships join, fetch all people for the municipality, compute their OCD IDs, find matching. For efficiency, accept that the first request may be slightly slow. Serialize with `serializePersonDetail`. Return with `ocdDetailResponse`.
- **Important**: People are scoped to municipality via `memberships` -> `organizations` join (no `municipality_id` on people table). Use the same scoping pattern as the existing v1 people endpoint.

**router.ts** -- OCD sub-router:
- Create a new `Hono<ApiEnv>()` instance for OCD routes.
- Apply `municipality` middleware to all routes: `ocdApp.use("/:municipality/*", municipality)`.
- Register a discovery endpoint at `GET /:municipality/` that returns a JSON object listing all available entity endpoints:
  ```json
  {
    "jurisdictions_url": "/api/ocd/{municipality}/jurisdictions",
    "organizations_url": "/api/ocd/{municipality}/organizations",
    "people_url": "/api/ocd/{municipality}/people",
    "events_url": "/api/ocd/{municipality}/events",
    "bills_url": "/api/ocd/{municipality}/bills",
    "votes_url": "/api/ocd/{municipality}/votes"
  }
  ```
  Replace `{municipality}` with the actual municipality slug from context.
- Register Jurisdiction routes: `GET /:municipality/jurisdictions` -> `listJurisdictions`, `GET /:municipality/jurisdictions/:id` -> `getJurisdiction`.
- Register Organization routes: `GET /:municipality/organizations` -> `listOrganizations`, `GET /:municipality/organizations/:id` -> `getOrganization`.
- Register People routes: `GET /:municipality/people` -> `listPeople`, `GET /:municipality/people/:id` -> `getPerson`.
- Leave space for Plan 03 to add Event, Bill, Vote routes (just a comment).
- Export the router as default.

**index.ts** -- Mount the OCD router:
- Import the OCD router: `import ocdApp from "./ocd/router"`.
- Mount it: `app.route("/api/ocd", ocdApp)` -- add this BEFORE the `export default app` line.
- The existing CORS middleware (`*`) and error handler already apply to all routes including `/api/ocd/*`.
- Do NOT add apiKeyAuth or rateLimit middleware to OCD routes (public access per user decision).
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | grep -E "ocd/" | head -30` to verify no TypeScript errors. Then run `cd apps/web && pnpm build 2>&1 | tail -20` to verify the build succeeds with the new routes mounted.
  </verify>
  <done>
Six endpoint handlers (3 list + 3 detail) return OCD-compliant JSON for Jurisdiction, Organization, and Person entities. The OCD router is mounted at `/api/ocd/` with municipality middleware only (no auth). A discovery endpoint lists all available entity URLs. All responses include full OCD spec fields with null for empty values. Page-based pagination works with page/per_page query params.
  </done>
</task>

</tasks>

<verification>
1. `GET /api/ocd/view-royal/` returns discovery JSON with all 6 entity URLs
2. `GET /api/ocd/view-royal/jurisdictions` returns a list with 1 jurisdiction, correct OCD ID using CSD 5917047
3. `GET /api/ocd/view-royal/jurisdictions/{id}` returns full jurisdiction detail
4. `GET /api/ocd/view-royal/organizations` returns paginated list of organizations with OCD IDs
5. `GET /api/ocd/view-royal/organizations/{id}` returns organization detail with posts derived from memberships
6. `GET /api/ocd/view-royal/people` returns paginated list of people with OCD IDs
7. `GET /api/ocd/view-royal/people/{id}` returns person detail with memberships
8. All responses have full OCD spec fields (null when empty)
9. No authentication required for any OCD endpoint
10. Pagination uses OpenStates format: `{ results, pagination: { page, per_page, max_page, total_items } }`
11. Build completes successfully with `pnpm build`
</verification>

<success_criteria>
- Three OCD entity types (Jurisdiction, Organization, Person) fully functional with list + detail endpoints
- OCD router mounted at `/api/ocd/` with discovery endpoint
- Public access (no API key required)
- OpenStates-style pagination on list endpoints
- All OCD spec fields present in every response
- TypeScript compiles and production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/17-ocd-interoperability/17-02-SUMMARY.md`
</output>
