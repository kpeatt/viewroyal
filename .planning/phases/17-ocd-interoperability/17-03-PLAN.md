---
phase: 17-ocd-interoperability
plan: 03
type: execute
wave: 3
depends_on: [17-02]
files_modified:
  - apps/web/app/api/ocd/serializers/event.ts
  - apps/web/app/api/ocd/serializers/bill.ts
  - apps/web/app/api/ocd/serializers/vote.ts
  - apps/web/app/api/ocd/endpoints/events.ts
  - apps/web/app/api/ocd/endpoints/bills.ts
  - apps/web/app/api/ocd/endpoints/votes.ts
  - apps/web/app/api/ocd/router.ts
autonomous: true
requirements: [OCD-04, OCD-05, OCD-06]

must_haves:
  truths:
    - "API consumer can GET /api/ocd/:municipality/events and receive paginated OCD Event objects with agenda, participants, and media"
    - "API consumer can GET /api/ocd/:municipality/events/:id and receive a single OCD Event with full nested data"
    - "API consumer can GET /api/ocd/:municipality/bills and receive paginated OCD Bill objects with actions and sponsors"
    - "API consumer can GET /api/ocd/:municipality/bills/:id and receive a single OCD Bill with full action history"
    - "API consumer can GET /api/ocd/:municipality/votes and receive paginated OCD Vote objects with vote_counts and roll_call"
    - "API consumer can GET /api/ocd/:municipality/votes/:id and receive a single OCD Vote with full roll call"
    - "Event agenda items are inlined in the Event response (not linked)"
    - "Bill session field uses the calendar year of the matter's first_seen date"
    - "Vote vote_counts are computed from actual roll call data for consistency"
    - "Events can be filtered by date range (before/after query params)"
    - "Bills can be filtered by status"
    - "Votes can be filtered by date range"
  artifacts:
    - path: "apps/web/app/api/ocd/serializers/event.ts"
      provides: "Meeting to OCD Event mapping with agenda, participants, media"
      exports: ["serializeEventSummary", "serializeEventDetail"]
    - path: "apps/web/app/api/ocd/serializers/bill.ts"
      provides: "Matter to OCD Bill mapping with actions and sponsors"
      exports: ["serializeBillSummary", "serializeBillDetail"]
    - path: "apps/web/app/api/ocd/serializers/vote.ts"
      provides: "Motion to OCD Vote mapping with vote_counts and roll_call"
      exports: ["serializeVoteSummary", "serializeVoteDetail"]
    - path: "apps/web/app/api/ocd/endpoints/events.ts"
      provides: "Event list and detail handlers"
      exports: ["listEvents", "getEvent"]
    - path: "apps/web/app/api/ocd/endpoints/bills.ts"
      provides: "Bill list and detail handlers"
      exports: ["listBills", "getBill"]
    - path: "apps/web/app/api/ocd/endpoints/votes.ts"
      provides: "Vote list and detail handlers"
      exports: ["listVotes", "getVote"]
  key_links:
    - from: "apps/web/app/api/ocd/endpoints/events.ts"
      to: "apps/web/app/api/ocd/serializers/event.ts"
      via: "import serializeEventDetail"
      pattern: "serializeEvent"
    - from: "apps/web/app/api/ocd/serializers/vote.ts"
      to: "votes table"
      via: "Roll call from individual votes, not summary columns"
      pattern: "vote_type"
    - from: "apps/web/app/api/ocd/serializers/bill.ts"
      to: "agenda_items + motions"
      via: "Actions from agenda item timeline, sponsors from motion movers"
      pattern: "actions.*agenda"
    - from: "apps/web/app/api/ocd/router.ts"
      to: "apps/web/app/api/ocd/endpoints/events.ts"
      via: "Route registration for events, bills, votes"
      pattern: "listEvents|listBills|listVotes"
---

<objective>
Build OCD Event, Bill, and Vote serializers and endpoints -- the three complex entity types that require deeply nested related data (agenda items, participants, media, actions, sponsors, roll call). Register all routes in the existing OCD router.

Purpose: Complete the OCD entity layer with the three most complex mappings. Events map from meetings with inline agenda and attendance. Bills map from matters with action timeline from agenda item appearances. Votes map from motions with roll call from the individual votes table.

Output: Six new endpoint files, three serializer files, and an updated router with all OCD entity routes.
</objective>

<execution_context>
@/Users/kyle/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kyle/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-ocd-interoperability/17-RESEARCH.md
@.planning/phases/17-ocd-interoperability/17-01-SUMMARY.md
@.planning/phases/17-ocd-interoperability/17-02-SUMMARY.md

# OCD utilities and router from prior plans
@apps/web/app/api/ocd/lib/ocd-ids.ts
@apps/web/app/api/ocd/lib/pagination.ts
@apps/web/app/api/ocd/lib/ocd-envelope.ts
@apps/web/app/api/ocd/router.ts
@apps/web/app/api/ocd/serializers/jurisdiction.ts
@apps/web/app/api/ocd/serializers/organization.ts
@apps/web/app/api/ocd/serializers/person.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event, Bill, and Vote serializers</name>
  <files>
    apps/web/app/api/ocd/serializers/event.ts
    apps/web/app/api/ocd/serializers/bill.ts
    apps/web/app/api/ocd/serializers/vote.ts
  </files>
  <action>
Create three complex serializer modules following the allowlist pattern. These are the most involved mappings due to deeply nested related data.

**event.ts** -- Map meetings to OCD Event:
- `serializeEventSummary(meeting: any, ocdId: string)` -- lightweight for list view:
  ```
  {
    id: ocdId,
    name: meeting.title ?? null,
    description: meeting.summary ?? "",
    classification: mapMeetingTypeToClassification(meeting.type),
    start_time: meeting.meeting_date ? `${meeting.meeting_date}T00:00:00-08:00` : null,
    timezone: "America/Vancouver",
    end_time: null,
    all_day: false,
    status: "passed",  // All historical meetings
    location: { url: null, name: "View Royal Town Hall", coordinates: null },
    sources: [{ url: meeting.agenda_url ?? meeting.minutes_url ?? "", note: null }],
    created_at: meeting.created_at ?? null,
    updated_at: meeting.created_at ?? null
  }
  ```
- `serializeEventDetail(meeting: any, ocdId: string, related: { agendaItems: any[], attendance: any[], attendeeOcdIds: Map<number, string> })` -- full nested detail:
  - Include all summary fields plus:
  - `media`: If `meeting.video_url` exists, `[{ note: "Video recording", date: meeting.meeting_date, offset: null, links: [{ media_type: "text/html", url: meeting.video_url, text: "" }] }]`, else `[]`.
  - `links`: Build from `meeting.agenda_url` ("Agenda") and `meeting.minutes_url` ("Minutes"). Only include non-null URLs.
  - `participants`: Map attendance records: `{ note: "attendee", name: person.name, entity_type: "person", entity_name: person.name, entity_id: attendeeOcdIds.get(person.id) ?? null }`.
  - `agenda`: Inline agenda items: `{ description: item.title, classification: item.category ?? null, order: item.item_order ?? null, subjects: [], notes: [], related_entities: [], media: [] }`.
  - `documents`: Build from agenda_url and minutes_url as PDF documents: `{ note: "Agenda document", date: meeting.meeting_date, media_type: "application/pdf", url: meeting.agenda_url, text: "", links: [] }`.
  - `sources`: Same as summary.
- `mapMeetingTypeToClassification(type: string): string` -- Use mapping from RESEARCH.md: `Regular Council` -> `meeting`, `Special Council` -> `meeting`, `Committee of the Whole` -> `meeting`, `Public Hearing` -> `hearing`, `Board of Variance` -> `hearing`, `Standing Committee` -> `meeting`, `Advisory Committee` -> `meeting`, default -> `meeting`.

**bill.ts** -- Map matters to OCD Bill:
- `serializeBillSummary(matter: any, ocdId: string, organizationOcdId: string)` -- lightweight:
  ```
  {
    id: ocdId,
    session: matter.first_seen ? new Date(matter.first_seen).getFullYear().toString() : null,
    name: matter.identifier ?? null,
    title: matter.title ?? null,
    type: [matter.category?.toLowerCase() ?? "resolution"],
    subject: matter.category ? [matter.category] : [],
    classification: [matter.category?.toLowerCase() ?? "resolution"],
    organization_id: organizationOcdId,
    from_organization_id: null,
    chamber: null,
    extras: {},
    created_at: matter.created_at ?? null,
    updated_at: matter.created_at ?? null,
    sources: []
  }
  ```
- `serializeBillDetail(matter: any, ocdId: string, organizationOcdId: string, related: { agendaItems: any[], motions: any[], moverOcdIds: Map<number, string> })` -- full detail:
  - Include all summary fields plus:
  - `summaries`: If `matter.description` exists, `[{ note: "Description", text: matter.description }]`, else `[]`.
  - `sponsors`: Derive from motions that have movers. For each motion with a non-null `mover` name and `mover_person_id`, create `{ entity_type: "person", name: mover, entity_id: moverOcdIds.get(mover_person_id) ?? null, classification: "mover", primary: true }`. Deduplicate by person name (a person may move multiple motions for the same matter).
  - `actions`: Map from agenda item appearances (full history per RESEARCH.md recommendation). For each agenda_item linked to this matter: `{ organization_id: organizationOcdId, description: agendaItem.title ?? "Discussion", date: agendaItem.meeting?.meeting_date ?? null, classification: [], order: index + 1, extras: {} }`. Sort by meeting date ascending.
  - `documents`: If `matter.document_url` exists, `[{ note: "Supporting document", date: null, media_type: "application/pdf", url: matter.document_url, text: "", links: [] }]`, else `[]`.
  - `versions`: Empty array `[]` (municipal matters don't have versioned text).
  - `other_titles`: Empty array `[]`.
  - `related_bills`: Empty array `[]`.

**vote.ts** -- Map motions to OCD Vote:
- `serializeVoteSummary(motion: any, ocdId: string, organizationOcdId: string)` -- lightweight:
  ```
  {
    id: ocdId,
    organization_id: organizationOcdId,
    organization: { name: motion.organization_name ?? "Council" },
    session: motion.meeting_date ? new Date(motion.meeting_date).getFullYear().toString() : null,
    chamber: null,
    date: motion.meeting_date ?? null,
    motion: motion.text_content ?? motion.plain_english_summary ?? null,
    type: ["bill-passage"],
    passed: mapResultToPassed(motion.result),
    created_at: motion.created_at ?? null,
    updated_at: motion.created_at ?? null,
    sources: []
  }
  ```
- `serializeVoteDetail(motion: any, ocdId: string, organizationOcdId: string, related: { individualVotes: any[], voterOcdIds: Map<number, string>, billOcdId: string | null })` -- full detail with roll call:
  - Include all summary fields plus:
  - `bill`: If `related.billOcdId`, `{ id: related.billOcdId, name: motion.matter_title ?? null, chamber: null }`, else `null`.
  - `vote_counts`: **Compute from actual roll_call data, NOT from summary columns** (per RESEARCH.md pitfall 3). Group `related.individualVotes` by mapped vote_type, count each. Format: `[{ vote_type: "yes", count: N }, { vote_type: "no", count: M }, ...]`.
  - `roll_call`: Map each individual vote: `{ person: { id: voterOcdIds.get(v.person_id) ?? null, name: v.person?.name ?? null }, vote_type: mapVoteValue(v.vote) }`.
  - If no individual votes exist (empty roll_call), return empty `roll_call: []` and derive `vote_counts` from the summary columns (`yes_votes`, `no_votes`, `abstain_votes`) as a fallback.

- `mapResultToPassed(result: string | null): boolean | null` -- Use mapping from RESEARCH.md:
  - `CARRIED`, `CARRIED AS AMENDED`, `CARRRIED`, `AMENDED` -> `true`
  - `DEFEATED`, `FAILED`, `FAILED FOR LACK OF A SECONDER`, `FAILED FOR LACK OF SECONDER`, `NOT CARRIED` -> `false`
  - `TABLED`, `WITHDRAWN` -> `null`
  - null/unknown -> `null`
- `mapVoteValue(vote: string | null): string` -- Use mapping from RESEARCH.md:
  - `Yes`, `YES`, `AYE`, `For` -> `"yes"`
  - `No`, `NO`, `Against` -> `"no"`
  - `Abstain`, `Recused` -> `"abstain"`
  - `Absent`, `No Vote` -> `"absent"`
  - default -> `"other"`

All serializers use JSDoc comments, allowlist construction, and full OCD spec field coverage.
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | grep -E "ocd/serializers" | head -20` to verify no TypeScript errors.
  </verify>
  <done>
Three complex OCD serializer modules exist with full spec field coverage. Event serializer maps meetings with inline agenda, participants, and media. Bill serializer maps matters with full action history and sponsors. Vote serializer maps motions with roll call computed from individual votes. All vote type and result mappings handle the known data variants from RESEARCH.md.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Event, Bill, and Vote endpoints and register routes</name>
  <files>
    apps/web/app/api/ocd/endpoints/events.ts
    apps/web/app/api/ocd/endpoints/bills.ts
    apps/web/app/api/ocd/endpoints/votes.ts
    apps/web/app/api/ocd/router.ts
  </files>
  <action>
Create endpoint handlers as plain Hono handler functions (same pattern as Plan 02's endpoints).

**events.ts** -- List and detail handlers:
- `listEvents` handler:
  - Parse pagination with `parsePaginationParams(c)`.
  - Parse optional filters: `before` (date string, filter `meeting_date <= before`), `after` (date string, filter `meeting_date >= after`) from query params.
  - Query `meetings` with `select("id, slug, title, meeting_date, type, video_url, agenda_url, minutes_url, summary, created_at, organization:organizations(name, id)", { count: "exact" })`, filtered by `municipality_id`.
  - Apply date filters if provided.
  - Order by `meeting_date` descending, then `id` descending.
  - Apply `.range(offset, offset + perPage - 1)`.
  - Pre-compute OCD IDs with `ocdIds("event", pks)`.
  - Serialize with `serializeEventSummary`.
  - Return with `ocdListResponse`.
- `getEvent` handler:
  - Accept `:id` param (the OCD event ID, e.g., `ocd-event/a3b2c1...`).
  - Use the reverse-lookup approach: fetch all meetings for the municipality, compute their OCD IDs, find the matching one. For 737 meetings this is acceptable for an MVP.
  - **Optimization**: Since the UUID v5 is deterministic, we could compute OCD IDs for all meetings and cache. But for MVP, compute per-request.
  - Fetch related data in parallel: agenda_items (with `select("id, title, item_order, category")`), attendance (with `select("attendance_mode, role, person:people(id, name, slug)")`).
  - Pre-compute attendee OCD IDs.
  - Serialize with `serializeEventDetail`.
  - Return with `ocdDetailResponse`.

**bills.ts** -- List and detail handlers:
- `listBills` handler:
  - Parse pagination. Parse optional filters: `status` (string), `updated_since` (date string) from query params.
  - Query `matters` with `select("id, title, identifier, description, status, category, first_seen, created_at", { count: "exact" })`.
  - Scope to municipality via `municipality_id`.
  - Apply filters.
  - Order by `first_seen` descending nulls last, then `id` descending.
  - Pre-compute OCD IDs with `ocdIds("bill", pks)`.
  - Get the Council organization's OCD ID for the `organization_id` field: query `organizations` where `classification = 'Council'` and `municipality_id = muni.id`, compute its OCD org ID.
  - Serialize with `serializeBillSummary`.
  - Return with `ocdListResponse`.
- `getBill` handler:
  - Accept `:id` param. Reverse-lookup by computing OCD IDs for all matters in the municipality (1727 rows -- acceptable for MVP).
  - Fetch related data: agenda_items linked to this matter (via `matter_id`), along with their meeting dates: `select("id, title, item_order, category, meeting:meetings(meeting_date)")`. Also fetch motions linked to the matter's agenda items: query `motions` where `agenda_item_id` in the matter's agenda item IDs, selecting `mover, mover_person_id`.
  - Pre-compute mover OCD IDs.
  - Serialize with `serializeBillDetail`.
  - Return with `ocdDetailResponse`.

**votes.ts** -- List and detail handlers:
- `listVotes` handler:
  - Parse pagination. Parse optional filters: `before` (date), `after` (date) from query params.
  - Query `motions` joined to `meetings` for municipality scoping and date access: `select("id, text_content, plain_english_summary, result, mover, seconder, yes_votes, no_votes, abstain_votes, created_at, meeting:meetings!inner(meeting_date, municipality_id, organization:organizations(name, id))", { count: "exact" })`.
  - Filter: `.eq("meeting.municipality_id", muni.id)`.
  - Apply date filters on `meeting.meeting_date`.
  - Order by `meeting.meeting_date` descending, then `id` descending.
  - Pre-compute OCD IDs with `ocdIds("vote", pks)`.
  - Get Council org OCD ID for `organization_id`.
  - Serialize with `serializeVoteSummary`.
  - Return with `ocdListResponse`.
- `getVote` handler:
  - Accept `:id` param. Reverse-lookup approach for motions (10536 rows -- this is the largest table).
  - **Optimization for votes**: Instead of computing all 10536 OCD IDs, paginate through motions in chunks of 1000 and stop when a match is found. Or accept the cost for MVP since it's a cold-path detail endpoint.
  - Fetch the motion with meeting info + agenda_item -> matter linkage.
  - Fetch individual votes: `select("id, vote, person_id, person:people(id, name)")` from `votes` where `motion_id = motion.id`.
  - Pre-compute voter OCD IDs.
  - If the motion has a linked matter (via agenda_item.matter_id), compute the bill OCD ID.
  - Serialize with `serializeVoteDetail`.
  - Return with `ocdDetailResponse`.

**router.ts** -- Add Event, Bill, Vote routes:
- Import `listEvents`, `getEvent` from `./endpoints/events`.
- Import `listBills`, `getBill` from `./endpoints/bills`.
- Import `listVotes`, `getVote` from `./endpoints/votes`.
- Register routes in the existing OCD router:
  ```
  ocdApp.get("/:municipality/events", listEvents);
  ocdApp.get("/:municipality/events/:id", getEvent);
  ocdApp.get("/:municipality/bills", listBills);
  ocdApp.get("/:municipality/bills/:id", getBill);
  ocdApp.get("/:municipality/votes", listVotes);
  ocdApp.get("/:municipality/votes/:id", getVote);
  ```
- Remove the placeholder comment for Plan 03 routes.
  </action>
  <verify>
Run `cd apps/web && npx tsc --noEmit --pretty 2>&1 | grep -E "ocd/" | head -30` to verify no TypeScript errors. Then run `cd apps/web && pnpm build 2>&1 | tail -20` to verify the build succeeds with all OCD routes.
  </verify>
  <done>
All six OCD entity types have list + detail endpoints. Events include inline agenda, participants, and media. Bills include full action history and sponsors. Votes include roll call computed from individual vote records. Date and status filters work on list endpoints. All routes registered in the OCD router. Production build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `GET /api/ocd/view-royal/events` returns paginated events with OCD Event fields
2. `GET /api/ocd/view-royal/events?after=2024-01-01&before=2024-12-31` filters by date range
3. `GET /api/ocd/view-royal/events/{id}` returns full event with inline agenda, participants, media, documents
4. `GET /api/ocd/view-royal/bills` returns paginated bills with OCD Bill fields
5. `GET /api/ocd/view-royal/bills?status=Active` filters by status
6. `GET /api/ocd/view-royal/bills/{id}` returns bill with actions (agenda item timeline) and sponsors (motion movers)
7. `GET /api/ocd/view-royal/votes` returns paginated votes with OCD Vote fields
8. `GET /api/ocd/view-royal/votes/{id}` returns vote with vote_counts computed from roll_call + individual roll call entries
9. Vote `passed` boolean correctly maps from motion result (CARRIED -> true, DEFEATED -> false, TABLED -> null)
10. Roll call `vote_type` correctly maps from vote values (Yes -> yes, No -> no, Abstain -> abstain, Absent -> absent)
11. Bill `session` field uses calendar year from matter.first_seen
12. All responses have full OCD spec fields (null/empty when data unavailable)
13. `pnpm build` succeeds with all routes
</verification>

<success_criteria>
- All six OCD entity types (Jurisdiction, Organization, Person, Event, Bill, Vote) have working list + detail endpoints
- Complex nested data correctly mapped: Event agenda/participants/media, Bill actions/sponsors, Vote roll_call/vote_counts
- Date and status filters work on applicable list endpoints
- Vote counts computed from actual roll call data (not summary columns) for consistency
- Full OCD spec field coverage in all responses
- Production build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/17-ocd-interoperability/17-03-SUMMARY.md`
</output>
