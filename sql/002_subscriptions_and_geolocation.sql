-- Migration: User Subscriptions, Email Alerts & Geolocation
-- Depends on: bootstrap.sql (001)
--
-- Adds:
--   1. PostGIS extension for proper geographic queries
--   2. user_profiles table (linked to Supabase Auth)
--   3. subscriptions table (matter, topic, person, neighborhood, digest)
--   4. alert_log table (deduplication)
--   5. Geography columns on agenda_items and matters
--   6. RPC function for proximity-based matter search
--   7. Meeting digest generation helper

-- ============================================================
-- 1. ENABLE POSTGIS
-- ============================================================
CREATE EXTENSION IF NOT EXISTS postgis;

-- ============================================================
-- 2. SUBSCRIPTION TYPE ENUM
-- ============================================================
DO $$ BEGIN
    CREATE TYPE subscription_type AS ENUM (
        'matter',          -- Follow a specific matter
        'topic',           -- Follow a topic category
        'person',          -- Follow a councillor's activity
        'neighborhood',    -- Alerts for a geographic area
        'digest'           -- Weekly/per-meeting digest
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE digest_frequency AS ENUM (
        'each_meeting',    -- After every meeting with substantive content
        'weekly'           -- Weekly rollup
    );
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================================
-- 3. USER PROFILES
-- ============================================================
CREATE TABLE IF NOT EXISTS user_profiles (
    id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    display_name text,
    address text,                              -- Street address for proximity matching
    neighborhood text,                         -- View Royal neighborhood
    location geography(Point, 4326),           -- Geocoded address for proximity queries
    notification_email text,                   -- Override email (defaults to auth email)
    email_verified boolean DEFAULT false,
    digest_frequency digest_frequency DEFAULT 'each_meeting',
    digest_enabled boolean DEFAULT true,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL
);

CREATE TRIGGER set_timestamp_user_profiles
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

CREATE INDEX IF NOT EXISTS idx_user_profiles_location
    ON user_profiles USING GIST (location);

CREATE INDEX IF NOT EXISTS idx_user_profiles_neighborhood
    ON user_profiles (neighborhood);

-- ============================================================
-- 4. SUBSCRIPTIONS
-- ============================================================
CREATE TABLE IF NOT EXISTS subscriptions (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
    type subscription_type NOT NULL,

    -- Polymorphic target (only one should be set per type)
    matter_id bigint REFERENCES matters(id) ON DELETE CASCADE,
    topic_id bigint REFERENCES topics(id) ON DELETE CASCADE,
    person_id bigint REFERENCES people(id) ON DELETE CASCADE,
    neighborhood text,            -- For neighborhood subscriptions

    -- Proximity settings (for neighborhood type)
    proximity_radius_m int DEFAULT 1000,  -- Radius in meters

    is_active boolean DEFAULT true,
    created_at timestamptz DEFAULT now() NOT NULL,
    updated_at timestamptz DEFAULT now() NOT NULL,

    -- Prevent duplicate subscriptions
    UNIQUE NULLS NOT DISTINCT (user_id, type, matter_id, topic_id, person_id, neighborhood)
);

CREATE TRIGGER set_timestamp_subscriptions
    BEFORE UPDATE ON subscriptions
    FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions (user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_type ON subscriptions (type);
CREATE INDEX IF NOT EXISTS idx_subscriptions_matter ON subscriptions (matter_id) WHERE matter_id IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_subscriptions_person ON subscriptions (person_id) WHERE person_id IS NOT NULL;

-- ============================================================
-- 5. ALERT LOG (deduplication & delivery tracking)
-- ============================================================
CREATE TABLE IF NOT EXISTS alert_log (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES user_profiles(id) ON DELETE CASCADE NOT NULL,
    subscription_id bigint REFERENCES subscriptions(id) ON DELETE SET NULL,
    meeting_id bigint REFERENCES meetings(id) ON DELETE CASCADE,
    agenda_item_id bigint REFERENCES agenda_items(id) ON DELETE SET NULL,
    motion_id bigint REFERENCES motions(id) ON DELETE SET NULL,

    alert_type text NOT NULL,     -- 'digest', 'matter_update', 'proximity_alert', etc.
    email_sent boolean DEFAULT false,
    sent_at timestamptz,
    error_message text,

    created_at timestamptz DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_alert_log_user_meeting
    ON alert_log (user_id, meeting_id, alert_type);

-- ============================================================
-- 6. ADD GEOGRAPHY COLUMNS TO EXISTING TABLES
-- ============================================================

-- Add geography point to agenda_items for spatial queries
-- (Replaces the existing JSONB geo_location with a proper PostGIS column)
ALTER TABLE agenda_items
    ADD COLUMN IF NOT EXISTS geo geography(Point, 4326);

CREATE INDEX IF NOT EXISTS idx_agenda_items_geo
    ON agenda_items USING GIST (geo);

-- Add geography point to matters
ALTER TABLE matters
    ADD COLUMN IF NOT EXISTS geo geography(Point, 4326);

CREATE INDEX IF NOT EXISTS idx_matters_geo
    ON matters USING GIST (geo);

-- ============================================================
-- 7. RPC: FIND MATTERS NEAR A POINT
-- ============================================================
CREATE OR REPLACE FUNCTION find_matters_near(
    lat double precision,
    lng double precision,
    radius_m int DEFAULT 1000,
    result_limit int DEFAULT 50
)
RETURNS TABLE (
    id bigint,
    title text,
    identifier text,
    category text,
    status text,
    distance_m double precision,
    related_address text
)
LANGUAGE plpgsql
AS $$
DECLARE
    search_point geography;
BEGIN
    search_point := ST_SetSRID(ST_MakePoint(lng, lat), 4326)::geography;

    RETURN QUERY
    SELECT DISTINCT ON (m.id)
        m.id,
        m.title,
        m.identifier,
        m.category,
        m.status,
        ST_Distance(COALESCE(ai.geo, m.geo), search_point) AS distance_m,
        ai.related_address
    FROM matters m
    LEFT JOIN agenda_items ai ON ai.matter_id = m.id AND ai.geo IS NOT NULL
    WHERE
        (m.geo IS NOT NULL AND ST_DWithin(m.geo, search_point, radius_m))
        OR
        (ai.geo IS NOT NULL AND ST_DWithin(ai.geo, search_point, radius_m))
    ORDER BY m.id, distance_m
    LIMIT result_limit;
END;
$$;

COMMENT ON FUNCTION find_matters_near IS 'Find matters within a radius (meters) of a lat/lng point, using PostGIS geography.';

-- ============================================================
-- 8. RPC: BUILD MEETING DIGEST
-- Returns the substantive content of a meeting for digest emails.
-- Only returns data when the meeting has minutes or a transcript.
-- ============================================================
CREATE OR REPLACE FUNCTION build_meeting_digest(target_meeting_id bigint)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    meeting_rec record;
    result jsonb;
BEGIN
    -- Get meeting, bail if agenda-only
    SELECT * INTO meeting_rec
    FROM meetings
    WHERE id = target_meeting_id;

    IF NOT FOUND THEN
        RETURN NULL;
    END IF;

    -- Only produce digest if we have substantive content
    IF NOT meeting_rec.has_minutes AND NOT meeting_rec.has_transcript THEN
        RETURN NULL;
    END IF;

    -- Build the digest payload
    SELECT jsonb_build_object(
        'meeting', jsonb_build_object(
            'id', meeting_rec.id,
            'title', meeting_rec.title,
            'meeting_date', meeting_rec.meeting_date,
            'type', meeting_rec.type,
            'summary', meeting_rec.summary,
            'has_minutes', meeting_rec.has_minutes,
            'has_transcript', meeting_rec.has_transcript
        ),
        'key_decisions', COALESCE((
            SELECT jsonb_agg(jsonb_build_object(
                'motion_id', mot.id,
                'agenda_item_title', ai.title,
                'motion_text', mot.plain_english_summary,
                'result', mot.result,
                'yes_votes', mot.yes_votes,
                'no_votes', mot.no_votes,
                'is_divided', (mot.no_votes > 0),
                'financial_cost', ai.financial_cost,
                'neighborhood', ai.neighborhood,
                'related_address', ai.related_address
            ) ORDER BY mot.id)
            FROM motions mot
            JOIN agenda_items ai ON ai.id = mot.agenda_item_id
            WHERE mot.meeting_id = target_meeting_id
              AND mot.disposition = 'Substantive'
        ), '[]'::jsonb),
        'controversial_items', COALESCE((
            SELECT jsonb_agg(jsonb_build_object(
                'id', ai.id,
                'title', ai.title,
                'summary', ai.plain_english_summary,
                'debate_summary', ai.debate_summary,
                'neighborhood', ai.neighborhood,
                'related_address', ai.related_address
            ) ORDER BY ai.id)
            FROM agenda_items ai
            WHERE ai.meeting_id = target_meeting_id
              AND ai.is_controversial = true
        ), '[]'::jsonb),
        'attendance', COALESCE((
            SELECT jsonb_agg(jsonb_build_object(
                'person_name', p.name,
                'mode', att.attendance_mode
            ))
            FROM attendance att
            JOIN people p ON p.id = att.person_id
            WHERE att.meeting_id = target_meeting_id
        ), '[]'::jsonb)
    ) INTO result;

    RETURN result;
END;
$$;

COMMENT ON FUNCTION build_meeting_digest IS 'Build a JSON digest payload for a meeting. Returns NULL if the meeting only has an agenda (no minutes or transcript).';

-- ============================================================
-- 9. RPC: FIND USERS TO NOTIFY FOR A MEETING
-- Matches meeting content against active subscriptions
-- ============================================================
CREATE OR REPLACE FUNCTION find_meeting_subscribers(target_meeting_id bigint)
RETURNS TABLE (
    user_id uuid,
    subscription_id bigint,
    subscription_type subscription_type,
    notification_email text
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY

    -- Digest subscribers (everyone who wants meeting digests)
    SELECT DISTINCT
        s.user_id,
        s.id AS subscription_id,
        s.type AS subscription_type,
        COALESCE(up.notification_email, au.email) AS notification_email
    FROM subscriptions s
    JOIN user_profiles up ON up.id = s.user_id
    JOIN auth.users au ON au.id = s.user_id
    WHERE s.type = 'digest'
      AND s.is_active = true
      AND up.digest_enabled = true

    UNION

    -- Matter subscribers (meeting discusses their followed matter)
    SELECT DISTINCT
        s.user_id,
        s.id AS subscription_id,
        s.type AS subscription_type,
        COALESCE(up.notification_email, au.email) AS notification_email
    FROM subscriptions s
    JOIN user_profiles up ON up.id = s.user_id
    JOIN auth.users au ON au.id = s.user_id
    JOIN agenda_items ai ON ai.matter_id = s.matter_id
    WHERE s.type = 'matter'
      AND s.is_active = true
      AND ai.meeting_id = target_meeting_id

    UNION

    -- Person subscribers (their followed councillor moved/seconded a motion)
    SELECT DISTINCT
        s.user_id,
        s.id AS subscription_id,
        s.type AS subscription_type,
        COALESCE(up.notification_email, au.email) AS notification_email
    FROM subscriptions s
    JOIN user_profiles up ON up.id = s.user_id
    JOIN auth.users au ON au.id = s.user_id
    JOIN motions mot ON mot.meeting_id = target_meeting_id
        AND (mot.mover_id = s.person_id OR mot.seconder_id = s.person_id)
    WHERE s.type = 'person'
      AND s.is_active = true

    UNION

    -- Neighborhood/proximity subscribers
    SELECT DISTINCT
        s.user_id,
        s.id AS subscription_id,
        s.type AS subscription_type,
        COALESCE(up.notification_email, au.email) AS notification_email
    FROM subscriptions s
    JOIN user_profiles up ON up.id = s.user_id
    JOIN auth.users au ON au.id = s.user_id
    JOIN agenda_items ai ON ai.meeting_id = target_meeting_id
    WHERE s.type = 'neighborhood'
      AND s.is_active = true
      AND up.location IS NOT NULL
      AND ai.geo IS NOT NULL
      AND ST_DWithin(ai.geo, up.location, s.proximity_radius_m);
END;
$$;

COMMENT ON FUNCTION find_meeting_subscribers IS 'Find all users who should be notified about a specific meeting based on their subscriptions.';

-- ============================================================
-- 10. ROW LEVEL SECURITY
-- ============================================================
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE alert_log ENABLE ROW LEVEL SECURITY;

-- Users can read/write their own profile
CREATE POLICY "Users can view own profile"
    ON user_profiles FOR SELECT
    USING (auth.uid() = id);

CREATE POLICY "Users can update own profile"
    ON user_profiles FOR UPDATE
    USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile"
    ON user_profiles FOR INSERT
    WITH CHECK (auth.uid() = id);

-- Service role full access to user_profiles
CREATE POLICY "Service role full access on user_profiles"
    ON user_profiles
    USING (auth.role() = 'service_role');

-- Users can manage their own subscriptions
CREATE POLICY "Users can view own subscriptions"
    ON subscriptions FOR SELECT
    USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own subscriptions"
    ON subscriptions FOR INSERT
    WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own subscriptions"
    ON subscriptions FOR UPDATE
    USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own subscriptions"
    ON subscriptions FOR DELETE
    USING (auth.uid() = user_id);

-- Service role full access to subscriptions
CREATE POLICY "Service role full access on subscriptions"
    ON subscriptions
    USING (auth.role() = 'service_role');

-- Users can view their own alert log
CREATE POLICY "Users can view own alerts"
    ON alert_log FOR SELECT
    USING (auth.uid() = user_id);

-- Service role full access to alert_log
CREATE POLICY "Service role full access on alert_log"
    ON alert_log
    USING (auth.role() = 'service_role');
