-- Migration: councillor_stances table, speaking time RPCs, category normalization
-- Phase 09-01: AI Profiling & Comparison foundation

-- ============================================================================
-- 1. councillor_stances table
-- ============================================================================
CREATE TABLE councillor_stances (
  id bigint generated by default as identity primary key,
  person_id bigint REFERENCES people(id) ON DELETE CASCADE NOT NULL,
  topic text NOT NULL,
  position text NOT NULL,        -- 'supports', 'opposes', 'mixed', 'neutral'
  position_score float,          -- -1.0 to 1.0
  summary text NOT NULL,
  evidence_quotes jsonb,         -- [{text, meeting_id, segment_id, date}]
  evidence_motion_ids bigint[],
  evidence_vote_ids bigint[],
  statement_count int NOT NULL,
  confidence text NOT NULL,      -- 'high', 'medium', 'low'
  generated_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  UNIQUE(person_id, topic)
);

-- Enable RLS
ALTER TABLE councillor_stances ENABLE ROW LEVEL SECURITY;

-- Stances are public data â€” allow anonymous and authenticated reads
CREATE POLICY "Allow public read access to councillor stances"
  ON councillor_stances
  FOR SELECT
  TO anon, authenticated
  USING (true);

-- ============================================================================
-- 2. normalize_category_to_topic(cat text) function
-- ============================================================================
CREATE OR REPLACE FUNCTION normalize_category_to_topic(cat text)
RETURNS text
LANGUAGE plpgsql IMMUTABLE
SET search_path = 'public'
AS $$
BEGIN
  IF cat IS NULL THEN RETURN 'General'; END IF;

  IF cat ILIKE ANY(ARRAY['%bylaw%', '%zoning%', '%rezoning%', '%regulatory%', '%legislat%'])
    THEN RETURN 'Bylaw';
  ELSIF cat ILIKE ANY(ARRAY['%develop%', '%planning%', '%land use%', '%permit%', '%ocp%', '%housing%', '%heritage%', '%subdivis%'])
    THEN RETURN 'Development';
  ELSIF cat ILIKE ANY(ARRAY['%environ%', '%park%', '%climate%', '%sustain%', '%trail%', '%tree%', '%conservation%', '%recreation%'])
    THEN RETURN 'Environment';
  ELSIF cat ILIKE ANY(ARRAY['%financ%', '%budget%', '%tax%', '%grant%', '%capital%', '%debt%', '%fund%'])
    THEN RETURN 'Finance';
  ELSIF cat ILIKE ANY(ARRAY['%transport%', '%traffic%', '%road%', '%transit%', '%cycl%', '%pedestr%', '%infrastruc%', '%engineer%'])
    THEN RETURN 'Transportation';
  ELSIF cat ILIKE ANY(ARRAY['%safe%', '%polic%', '%fire%', '%protect%', '%emergency%', '%rcmp%', '%enforcement%'])
    THEN RETURN 'Public Safety';
  ELSIF cat ILIKE ANY(ARRAY['%admin%', '%governance%', '%appoint%', '%committee%', '%procedur%', '%minutes%', '%agenda%', '%adjournm%', '%closed%', '%routine%', '%consent%'])
    THEN RETURN 'Administration';
  ELSE
    RETURN 'General';
  END IF;
END;
$$;

-- ============================================================================
-- 3. get_speaking_time_stats RPC
-- ============================================================================
CREATE OR REPLACE FUNCTION get_speaking_time_stats(
  p_start_date date DEFAULT NULL,
  p_end_date date DEFAULT NULL
)
RETURNS TABLE (
  person_id bigint,
  person_name text,
  image_url text,
  total_seconds numeric,
  meeting_count bigint,
  segment_count bigint
)
LANGUAGE plpgsql
SET search_path = 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ts.person_id,
    p.name AS person_name,
    p.image_url,
    round(sum(ts.end_time - ts.start_time)::numeric, 1) AS total_seconds,
    count(DISTINCT ts.meeting_id) AS meeting_count,
    count(*) AS segment_count
  FROM transcript_segments ts
  JOIN people p ON ts.person_id = p.id
  JOIN meetings m ON ts.meeting_id = m.id
  WHERE ts.person_id IS NOT NULL
    AND (p_start_date IS NULL OR m.meeting_date >= p_start_date)
    AND (p_end_date IS NULL OR m.meeting_date <= p_end_date)
  GROUP BY ts.person_id, p.name, p.image_url
  ORDER BY sum(ts.end_time - ts.start_time) DESC;
END;
$$;

-- ============================================================================
-- 4. get_speaking_time_by_meeting RPC
-- ============================================================================
CREATE OR REPLACE FUNCTION get_speaking_time_by_meeting(
  p_person_id bigint,
  p_start_date date DEFAULT NULL,
  p_end_date date DEFAULT NULL
)
RETURNS TABLE (
  meeting_id bigint,
  meeting_date date,
  seconds_spoken numeric,
  segment_count bigint
)
LANGUAGE plpgsql
SET search_path = 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT
    ts.meeting_id,
    m.meeting_date::date AS meeting_date,
    round(sum(ts.end_time - ts.start_time)::numeric, 1) AS seconds_spoken,
    count(*) AS segment_count
  FROM transcript_segments ts
  JOIN meetings m ON ts.meeting_id = m.id
  WHERE ts.person_id = p_person_id
    AND (p_start_date IS NULL OR m.meeting_date >= p_start_date)
    AND (p_end_date IS NULL OR m.meeting_date <= p_end_date)
  GROUP BY ts.meeting_id, m.meeting_date
  ORDER BY m.meeting_date ASC;
END;
$$;

-- ============================================================================
-- 5. get_speaking_time_by_topic RPC
-- ============================================================================
CREATE OR REPLACE FUNCTION get_speaking_time_by_topic(
  p_person_id bigint,
  p_start_date date DEFAULT NULL,
  p_end_date date DEFAULT NULL
)
RETURNS TABLE (
  topic text,
  total_seconds numeric,
  segment_count bigint
)
LANGUAGE plpgsql
SET search_path = 'public'
AS $$
BEGIN
  RETURN QUERY
  SELECT
    coalesce(
      normalize_category_to_topic(ai.category),
      'General'
    ) AS topic,
    round(sum(ts.end_time - ts.start_time)::numeric, 1) AS total_seconds,
    count(*) AS segment_count
  FROM transcript_segments ts
  JOIN meetings m ON ts.meeting_id = m.id
  LEFT JOIN agenda_items ai ON (
    -- Direct link via agenda_item_id if available
    (ts.agenda_item_id IS NOT NULL AND ai.id = ts.agenda_item_id)
    OR
    -- Time-overlap fallback: segment start_time falls within agenda item discussion window
    (ts.agenda_item_id IS NULL
     AND ai.meeting_id = ts.meeting_id
     AND ai.discussion_start_time IS NOT NULL
     AND ai.discussion_end_time IS NOT NULL
     AND ts.start_time >= ai.discussion_start_time
     AND ts.start_time < ai.discussion_end_time)
  )
  WHERE ts.person_id = p_person_id
    AND (p_start_date IS NULL OR m.meeting_date >= p_start_date)
    AND (p_end_date IS NULL OR m.meeting_date <= p_end_date)
  GROUP BY normalize_category_to_topic(ai.category)
  ORDER BY sum(ts.end_time - ts.start_time) DESC;
END;
$$;
